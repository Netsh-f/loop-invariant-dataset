[
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/crt/../ldso/dlstart.c",
    "line": 29,
    "column": 2,
    "source_code": "for (i=argc+1; argv[i]; i++);\n",
    "abstract_code": "for (i=argc+1; arr_argv[i]; i++);\n",
    "ptr_map": {
      "argv": "argv_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_argv[N];\n    size_t argc;\n    size_t i;\n\n    __CPROVER_assume(argc < N - 1);\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_argv[k] == 0 || arr_argv[k] == 1);\n    }\n\n    i = argc + 1;\n    while (i < N && arr_argv[i] != 0) {\n        __CPROVER_assert(i >= argc + 1 && i < N, \"Loop invariant: index within safe bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/crt/../ldso/dlstart.c",
    "line": 123,
    "column": 3,
    "source_code": "for (i=0; dynv[i]; i+=2) if (dynv[i]==DT_MIPS_LOCAL_GOTNO)\n\t\t\tlocal_cnt = dynv[i+1];",
    "abstract_code": "for (i=0; arr_dynv[i]; i+=2) if (arr_dynv[i]==DT_MIPS_LOCAL_GOTNO)\n\t\t\tlocal_cnt = arr_dynv[i+1];",
    "ptr_map": {
      "dynv": "dynv_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define DT_MIPS_LOCAL_GOTNO 123456\n\nint main() {\n    size_t arr_dynv[N];\n    size_t local_cnt = 0;\n    size_t i = 0;\n\n    __CPROVER_assume(N > 1);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_dynv[k] == 0 || arr_dynv[k] == DT_MIPS_LOCAL_GOTNO);\n    }\n\n    while (i < N && arr_dynv[i] != 0) {\n        __CPROVER_assert(\n            (local_cnt == 0) ||\n            (i >= 2 && arr_dynv[i - 2] == DT_MIPS_LOCAL_GOTNO && local_cnt == arr_dynv[i - 1]),\n            \"Loop invariant violated\"\n        );\n\n        if (arr_dynv[i] == DT_MIPS_LOCAL_GOTNO) {\n            __CPROVER_assume(i + 1 < N);\n            local_cnt = arr_dynv[i + 1];\n        }\n        i += 2;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/crt/../ldso/dlstart.c",
    "line": 125,
    "column": 3,
    "source_code": "for (i=0; i<local_cnt; i++) got[i] += base;",
    "abstract_code": "for (i=0; i<local_cnt; i++) arr_got[i] += base;",
    "ptr_map": {
      "got": "got_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_got[N];\n    size_t base;\n    size_t local_cnt;\n    size_t i = 0;\n\n    __CPROVER_assume(local_cnt <= N);\n    __CPROVER_assume(local_cnt > 0);\n\n    while (i < local_cnt) {\n        __CPROVER_assert(i < N, \"Loop index within array bounds\");\n        arr_got[i] += base;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/crt/../ldso/dlstart.c",
    "line": 152,
    "column": 4,
    "source_code": "for (size_t i=0, bitmap=rel[0]; bitmap>>=1; i++)\n\t\t\t\tif (bitmap&1)\n\t\t\t\t\trelr_addr[i] += base;",
    "abstract_code": "for (size_t i=0, bitmap=arr_rel[0]; bitmap>>=1; i++)\n\t\t\t\tif (bitmap&1)\n\t\t\t\t\tarr_relr_addr[i] += base;",
    "ptr_map": {
      "rel": "rel_idx",
      "relr_addr": "relr_addr_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n#define N 100\n\nint main() {\n    uintptr_t arr_rel[N];\n    uintptr_t arr_relr_addr[N];\n    uintptr_t base = 0;\n    size_t i = 0;\n    uintptr_t bitmap;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_relr_addr[k] < UINTPTR_MAX - base);\n    }\n\n    bitmap = arr_rel[0];\n    __CPROVER_assume(bitmap != 0);\n\n    while (bitmap >>= 1) {\n        __CPROVER_assert(i < N, \"Loop index within bounds\");\n        if (bitmap & 1) {\n            __CPROVER_assert(i < N, \"Write index within bounds\");\n            arr_relr_addr[i] += base;\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/a64l.c",
    "line": 25,
    "column": 2,
    "source_code": "for (p=s; x; p++, x>>=6)\n\t\t*p = digits[x&63];",
    "abstract_code": "for (p=s; x; p++, x>>=6)\n\t\t*p = arr_digits[x&63];",
    "ptr_map": {
      "digits": "digits_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    unsigned long x;\n    char s[N];\n    char *p;\n    char arr_digits[64];\n    int i;\n\n    __CPROVER_assume(x > 0);\n    p = s;\n\n    while (x != 0) {\n        __CPROVER_assert(p >= s && p < s + N, \"Loop invariant: pointer within bounds\");\n        *p = arr_digits[x & 63];\n        p++;\n        x >>= 6;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/wordexp.c",
    "line": 43,
    "column": 26,
    "source_code": "for (i=0; s[i]; i++) switch (s[i]) {\n\tcase '\\\\':\n\t\tif (!sq && !s[++i]) return WRDE_SYNTAX;\n\t\tbreak;\n\tcase '\\'':\n\t\tif (!dq) sq^=1;\n\t\tbreak;\n\tcase '\"':\n\t\tif (!sq) dq^=1;\n\t\tbreak;\n\tcase '(':\n\t\tif (np) {\n\t\t\tnp++;\n\t\t\tbreak;\n\t\t}\n\tcase ')':\n\t\tif (np) {\n\t\t\tnp--;\n\t\t\tbreak;\n\t\t}\n\tcase '\\n':\n\tcase '|':\n\tcase '&':\n\tcase ';':\n\tcase '<':\n\tcase '>':\n\tcase '{':\n\tcase '}':\n\t\tif (!(sq|dq|np)) return WRDE_BADCHAR;\n\t\tbreak;\n\tcase '$':\n\t\tif (sq) break;\n\t\tif (s[i+1]=='(' && s[i+2]=='(') {\n\t\t\ti += 2;\n\t\t\tnp += 2;\n\t\t\tbreak;\n\t\t} else if (s[i+1] != '(') break;\n\tcase '`':\n\t\tif (sq) break;\n\t\treturn WRDE_CMDSUB;\n\t}\n",
    "abstract_code": "for (i=0; arr_s[i]; i++) switch (arr_s[i]) {\n\tcase '\\\\':\n\t\tif (!sq && !arr_s[++i]) return WRDE_SYNTAX;\n\t\tbreak;\n\tcase '\\'':\n\t\tif (!dq) sq^=1;\n\t\tbreak;\n\tcase '\"':\n\t\tif (!sq) dq^=1;\n\t\tbreak;\n\tcase '(':\n\t\tif (np) {\n\t\t\tnp++;\n\t\t\tbreak;\n\t\t}\n\tcase ')':\n\t\tif (np) {\n\t\t\tnp--;\n\t\t\tbreak;\n\t\t}\n\tcase '\\n':\n\tcase '|':\n\tcase '&':\n\tcase ';':\n\tcase '<':\n\tcase '>':\n\tcase '{':\n\tcase '}':\n\t\tif (!(sq|dq|np)) return WRDE_BADCHAR;\n\t\tbreak;\n\tcase '$':\n\t\tif (sq) break;\n\t\tif (arr_s[i+1]=='(' && arr_s[i+2]=='(') {\n\t\t\ti += 2;\n\t\t\tnp += 2;\n\t\t\tbreak;\n\t\t} else if (arr_s[i+1] != '(') break;\n\tcase '`':\n\t\tif (sq) break;\n\t\treturn WRDE_CMDSUB;\n\t}\n",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdbool.h>\n#define N 100\n#define WRDE_SYNTAX 1\n#define WRDE_BADCHAR 2\n#define WRDE_CMDSUB 3\n\nint main() {\n    char arr_s[N];\n    bool sq = false, dq = false;\n    int np = 0;\n    size_t i = 0;\n\n    __CPROVER_assume(N > 2);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] == 0 || arr_s[k] == '\\\\' || arr_s[k] == '\\'' || arr_s[k] == '\"' || arr_s[k] == '(' || arr_s[k] == ')' || arr_s[k] == '\\n' || arr_s[k] == '|' || arr_s[k] == '&' || arr_s[k] == ';' || arr_s[k] == '<' || arr_s[k] == '>' || arr_s[k] == '{' || arr_s[k] == '}' || arr_s[k] == '$' || arr_s[k] == '`');\n    }\n\n    while (i < N && arr_s[i] != 0) {\n        __CPROVER_assert(\n            (sq == false || dq == false) &&\n            (np >= 0) &&\n            (sq == true || dq == true || np == 0 || (i > 0 && arr_s[i-1] == '(' && np > 0) || (i > 0 && arr_s[i-1] == ')' && np > 0) || (i > 1 && arr_s[i-2] == '$' && arr_s[i-1] == '(' && arr_s[i] == '(' && np >= 2)),\n            \"Loop invariant violated\"\n        );\n\n        switch (arr_s[i]) {\n            case '\\\\':\n                if (!sq && !arr_s[++i]) return WRDE_SYNTAX;\n                break;\n            case '\\'':\n                if (!dq) sq ^= 1;\n                break;\n            case '\"':\n                if (!sq) dq ^= 1;\n                break;\n            case '(':\n                if (np) {\n                    np++;\n                    break;\n                }\n            case ')':\n                if (np) {\n                    np--;\n                    break;\n                }\n            case '\\n':\n            case '|':\n            case '&':\n            case ';':\n            case '<':\n            case '>':\n            case '{':\n            case '}':\n                if (!(sq | dq | np)) return WRDE_BADCHAR;\n                break;\n            case '$':\n                if (sq) break;\n                if (arr_s[i+1]=='(' && arr_s[i+2]=='(') {\n                    i += 2;\n                    np += 2;\n                    break;\n                } else if (arr_s[i+1] != '(') break;\n            case '`':\n                if (sq) break;\n                return WRDE_CMDSUB;\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/basename.c",
    "line": 9,
    "column": 2,
    "source_code": "for (; i&&s[i]=='/'; i--) s[i] = 0;",
    "abstract_code": "for (; i&&arr_s[i]=='/'; i--) arr_s[i] = 0;",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_s[N];\n    size_t i = N - 1;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] == '/' || arr_s[k] != '/');\n    }\n\n    while (i > 0 && arr_s[i] == '/') {\n        __CPROVER_assert(i < N, \"Loop invariant: index within bounds\");\n        arr_s[i] = 0;\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/basename.c",
    "line": 10,
    "column": 2,
    "source_code": "for (; i&&s[i-1]!='/'; i--);\n",
    "abstract_code": "for (; i&&arr_s[i-1]!='/'; i--);\n",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_s[N];\n    size_t i = N - 1;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] != '/');\n    }\n\n    while (i > 0 && arr_s[i - 1] != '/') {\n        __CPROVER_assert(\n            i < N && (i == 0 || arr_s[i] == '/'),\n            \"Loop invariant violated\"\n        );\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/nftw.c",
    "line": 65,
    "column": 3,
    "source_code": "for (k=j; k && path[k]=='/'; k--);\n",
    "abstract_code": "for (k=j; k && arr_path[k]=='/'; k--);\n",
    "ptr_map": {
      "path": "path_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_path[N];\n    int j, k;\n    \n    __CPROVER_assume(j >= 0 && j < N);\n    for (size_t idx = 0; idx < N; idx++) {\n        __CPROVER_assume(arr_path[idx] == '/' || arr_path[idx] != '/');\n    }\n    \n    k = j;\n    while (k >= 0 && arr_path[k] == '/') {\n        __CPROVER_assert(k >= 0 && k < N, \"Loop invariant: index within bounds\");\n        k--;\n    }\n    \n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/nftw.c",
    "line": 66,
    "column": 3,
    "source_code": "for (; k && path[k-1]!='/'; k--);\n",
    "abstract_code": "for (; k && arr_path[k-1]!='/'; k--);\n",
    "ptr_map": {
      "path": "path_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_path[N];\n    size_t k = N - 1;\n\n    __CPROVER_assume(N > 0);\n    for (size_t i = 0; i < N; i++) {\n        __CPROVER_assume(arr_path[i] != 0);\n    }\n\n    while (k > 0 && arr_path[k - 1] != '/') {\n        __CPROVER_assert(k < N, \"Loop invariant: index k within bounds\");\n        k--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/dirname.c",
    "line": 9,
    "column": 2,
    "source_code": "for (; s[i]=='/'; i--) if (!i) return \"/\";",
    "abstract_code": "for (; arr_s[i]=='/'; i--) if (!i) return \"/\";",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_s[N];\n    int i = N - 1;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] == '/' || arr_s[k] != '/');\n    }\n\n    while (i >= 0 && arr_s[i] == '/') {\n        __CPROVER_assert(\n            i >= 0 && i < N,\n            \"Loop invariant: index within bounds\"\n        );\n\n        if (i == 0) {\n            return 0;\n        }\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/dirname.c",
    "line": 10,
    "column": 2,
    "source_code": "for (; s[i]!='/'; i--) if (!i) return \".\";",
    "abstract_code": "for (; arr_s[i]!='/'; i--) if (!i) return \".\";",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_s[N];\n    size_t i = N - 1;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] != 0);\n    }\n\n    while (i < N && arr_s[i] != '/') {\n        __CPROVER_assert(\n            i < N,\n            \"Loop invariant violated\"\n        );\n\n        if (i == 0) {\n            return 0;\n        }\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/dirname.c",
    "line": 11,
    "column": 2,
    "source_code": "for (; s[i]=='/'; i--) if (!i) return \"/\";",
    "abstract_code": "for (; arr_s[i]=='/'; i--) if (!i) return \"/\";",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_s[N];\n    size_t i = N - 1;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] == '/' || arr_s[k] != '/');\n    }\n\n    while (i < N && arr_s[i] == '/') {\n        __CPROVER_assert(\n            i < N,\n            \"Loop invariant: index in bounds\"\n        );\n\n        if (i == 0) {\n            return 0;\n        }\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/misc/fmtmsg.c",
    "line": 19,
    "column": 2,
    "source_code": "while (lstr[i] && bstr[i] && (bstr[i] == lstr[i])) i++;",
    "abstract_code": "while (arr_lstr[i] && arr_bstr[i] && (arr_bstr[i] == arr_lstr[i])) i++;",
    "ptr_map": {
      "bstr": "bstr_idx",
      "lstr": "lstr_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_lstr[N];\n    char arr_bstr[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_lstr[k] >= 0 && arr_lstr[k] <= 127);\n        __CPROVER_assume(arr_bstr[k] >= 0 && arr_bstr[k] <= 127);\n    }\n\n    while (i < N && arr_lstr[i] && arr_bstr[i] && (arr_bstr[i] == arr_lstr[i])) {\n        __CPROVER_assert(\n            i < N && arr_lstr[i] && arr_bstr[i] && (arr_bstr[i] == arr_lstr[i]),\n            \"Loop invariant violated\"\n        );\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/getopt_long.c",
    "line": 17,
    "column": 2,
    "source_code": "for (i=src; i>dest; i--)\n\t\tav[i] = av[i-1];",
    "abstract_code": "for (i=src; i>dest; i--)\n\t\tarr_av[i] = arr_av[i-1];",
    "ptr_map": {
      "av": "av_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_av[N];\n    size_t src, dest;\n    size_t i;\n\n    __CPROVER_assume(N > 0);\n    __CPROVER_assume(src < N);\n    __CPROVER_assume(dest < N);\n    __CPROVER_assume(src > dest);\n\n    i = src;\n    while (i > dest) {\n        __CPROVER_assert(i < N && i - 1 < N, \"Array access within bounds\");\n        arr_av[i] = arr_av[i - 1];\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/getopt_long.c",
    "line": 36,
    "column": 3,
    "source_code": "for (i=optind; ; i++) {\n\t\t\tif (i >= argc || !argv[i]) return -1;\n\t\t\tif (argv[i][0] == '-' && argv[i][1]) break;\n\t\t}\n",
    "abstract_code": "for (i=optind; ; i++) {\n\t\t\tif (i >= argc || !arr_argv[i]) return -1;\n\t\t\tif (arr_argv[i][0] == '-' && arr_argv[i][1]) break;\n\t\t}\n",
    "ptr_map": {
      "argv": "argv_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int argc = N;\n    int optind = 0;\n    int i;\n    char arr_argv[N][2];\n\n    __CPROVER_assume(optind >= 0 && optind < N);\n    for (int k = 0; k < N; k++) {\n        __CPROVER_assume(arr_argv[k][0] != 0);\n        __CPROVER_assume(arr_argv[k][1] != 0);\n    }\n\n    i = optind;\n    while (1) {\n        __CPROVER_assert(i >= optind && i < N, \"Loop invariant: i within safe range\");\n        if (i >= argc || !arr_argv[i]) return -1;\n        if (arr_argv[i][0] == '-' && arr_argv[i][1]) break;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/misc/getopt_long.c",
    "line": 82,
    "column": 5,
    "source_code": "for (j=0; j<l && start[j]==optstring[i+j]; j++);\n",
    "abstract_code": "for (j=0; j<l && arr_start[j]==arr_optstring[i+j]; j++);\n",
    "ptr_map": {
      "start": "start_idx",
      "optstring": "optstring_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define L 50\n\nint main() {\n    size_t arr_start[N];\n    size_t arr_optstring[N];\n    size_t i = 0;\n    size_t j = 0;\n    size_t l = L;\n\n    __CPROVER_assume(l > 0 && l < N);\n    __CPROVER_assume(i + l < N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_start[k] < 256);\n        __CPROVER_assume(arr_optstring[k] < 256);\n    }\n\n    while (j < l && arr_start[j] == arr_optstring[i + j]) {\n        __CPROVER_assert(\n            j < l && arr_start[j] == arr_optstring[i + j],\n            \"Loop invariant violated\"\n        );\n        j++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/misc/realpath.c",
    "line": 106,
    "column": 5,
    "source_code": "while(q && output[q-1]!='/') q--;",
    "abstract_code": "while(q && arr_output[q-1]!='/') q--;",
    "ptr_map": {
      "output": "output_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t output_idx[N];\n    size_t q = N - 1;\n    size_t i;\n\n    __CPROVER_assume(N > 0);\n    for (i = 0; i < N; i++) {\n        __CPROVER_assume(output_idx[i] != 0);\n    }\n\n    while (q > 0 && output_idx[q - 1] != '/') {\n        __CPROVER_assert(\n            (q < N) &&\n            (output_idx[q] == '/' || q == N - 1),\n            \"Loop invariant violated\"\n        );\n        q--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/misc/realpath.c",
    "line": 121,
    "column": 24,
    "source_code": "while (stack[p]=='/') p++;",
    "abstract_code": "while (arr_stack[p]=='/') p++;",
    "ptr_map": {
      "stack": "stack_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_stack[N];\n    size_t p = 0;\n\n    __CPROVER_assume(p < N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_stack[k] == '/' || arr_stack[k] == 'a');\n    }\n\n    while (p < N && arr_stack[p] == '/') {\n        __CPROVER_assert(p < N, \"Loop invariant: index within bounds\");\n        p++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/misc/realpath.c",
    "line": 138,
    "column": 4,
    "source_code": "while(l>1 && stack[l-1]!='/') l--;",
    "abstract_code": "while(l>1 && arr_stack[l-1]!='/') l--;",
    "ptr_map": {
      "stack": "stack_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_stack[N];\n    size_t l = N;\n\n    __CPROVER_assume(l > 1 && l <= N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_stack[k] != 0);\n    }\n\n    while (l > 1 && arr_stack[l - 1] != '/') {\n        __CPROVER_assert(l > 0 && l <= N, \"Loop invariant: l within bounds\");\n        l--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/wcsftime.c",
    "line": 44,
    "column": 4,
    "source_code": "for (; *t=='+' || *t=='-' || (*t=='0'&&t[1]); t++, k--);\n",
    "abstract_code": "for (; arr_t[t_idx]=='+' || arr_t[t_idx]=='-' || (arr_t[t_idx]=='0'&&arr_t[1]); t_idx++, k--);\n",
    "ptr_map": {
      "t": "t_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_t[N];\n    size_t t_idx = 0;\n    int k = 0;\n\n    __CPROVER_assume(N > 1);\n    for (size_t i = 0; i < N; i++) {\n        __CPROVER_assume(arr_t[i] == '+' || arr_t[i] == '-' || arr_t[i] == '0' || arr_t[i] == '\\0');\n    }\n\n    while (t_idx < N && (arr_t[t_idx] == '+' || arr_t[t_idx] == '-' || (arr_t[t_idx] == '0' && t_idx + 1 < N && arr_t[t_idx + 1] != '\\0'))) {\n        __CPROVER_assert(t_idx < N, \"Loop index within bounds\");\n        t_idx++;\n        k--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/wcsftime.c",
    "line": 52,
    "column": 4,
    "source_code": "for (; width > k && l < n; width--)\n\t\t\t\ts[l++] = '0';",
    "abstract_code": "for (; width > k && l < n; width--)\n\t\t\t\tarr_s[l++] = '0';",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_s[N];\n    int width = N;\n    int k = 0;\n    int l = 0;\n    int n = N;\n\n    __CPROVER_assume(width > 0 && k >= 0 && l >= 0 && n > 0 && n <= N);\n    __CPROVER_assume(width <= N);\n\n    while (width > k && l < n) {\n        __CPROVER_assert(l >= 0 && l < n, \"Array write bounds for arr_s\");\n        arr_s[l] = '0';\n        l++;\n        width--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/__secs_to_tm.c",
    "line": 60,
    "column": 2,
    "source_code": "for (months=0; days_in_month[months] <= remdays; months++)\n\t\tremdays -= days_in_month[months];",
    "abstract_code": "for (months=0; arr_days_in_month[months] <= remdays; months++)\n\t\tremdays -= arr_days_in_month[months];",
    "ptr_map": {
      "days_in_month": "days_in_month_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 12\n\nint main() {\n    int arr_days_in_month[N];\n    int remdays;\n    int months = 0;\n\n    __CPROVER_assume(remdays >= 0);\n    for (size_t k = 0; k < N; ++k) {\n        __CPROVER_assume(arr_days_in_month[k] > 0);\n    }\n\n    int initial_remdays = remdays;\n    int accumulated = 0;\n\n    while (months < N && arr_days_in_month[months] <= remdays) {\n        __CPROVER_assert(\n            remdays == initial_remdays - accumulated,\n            \"Loop invariant: remdays equals initial minus sum of subtracted days\"\n        );\n\n        accumulated += arr_days_in_month[months];\n        remdays -= arr_days_in_month[months];\n        months++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/strftime.c",
    "line": 257,
    "column": 4,
    "source_code": "for (; *t=='0' && t[1]-'0'<10U; t++, k--);\n",
    "abstract_code": "for (; arr_t[t_idx]=='0' && arr_t[1]-'0'<10U; t_idx++, k--);\n",
    "ptr_map": {
      "t": "t_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_t[N];\n    size_t t_idx = 0;\n    int k = 50;\n\n    __CPROVER_assume(N > 1);\n    for (size_t i = 0; i < N; i++) {\n        __CPROVER_assume(arr_t[i] >= '0' && arr_t[i] <= '9');\n    }\n\n    while (t_idx < N && arr_t[t_idx] == '0' && arr_t[1] - '0' < 10U) {\n        __CPROVER_assert(t_idx < N, \"Loop index t_idx within bounds\");\n        __CPROVER_assert(k >= 0, \"k non-negative\");\n        t_idx++;\n        k--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/strftime.c",
    "line": 260,
    "column": 4,
    "source_code": "for (d=0; t[d]-'0'<10U; d++);\n",
    "abstract_code": "for (d=0; arr_t[d]-'0'<10U; d++);\n",
    "ptr_map": {
      "t": "t_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_t[N];\n    size_t d = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_t[k] >= '0' && arr_t[k] <= '9');\n    }\n\n    while (d < N && arr_t[d] - '0' < 10U) {\n        __CPROVER_assert(d < N, \"Loop invariant: array index within bounds\");\n        d++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/strftime.c",
    "line": 268,
    "column": 4,
    "source_code": "for (; width > k && l < n; width--)\n\t\t\t\ts[l++] = '0';",
    "abstract_code": "for (; width > k && l < n; width--)\n\t\t\t\tarr_s[l++] = '0';",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_s[N];\n    size_t l = 0;\n    size_t n = N;\n    size_t width = N;\n    size_t k = 0;\n\n    __CPROVER_assume(width <= N && l < n && k < width);\n\n    while (width > k && l < n) {\n        __CPROVER_assert(l < n, \"Array write index bounds\");\n        __CPROVER_assert(l >= 0, \"Array write index non-negative\");\n\n        arr_s[l] = '0';\n        l++;\n        width--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/__tz.c",
    "line": 97,
    "column": 3,
    "source_code": "for (i=0; (*p)[i] && (*p)[i]!='>'; i++)\n\t\t\tif (i<TZNAME_MAX) d[i] = (*p)[i];",
    "abstract_code": "for (i=0; (*p)[i] && (*p)[i]!='>'; i++)\n\t\t\tif (i<TZNAME_MAX) arr_d[i] = (*p)[i];",
    "ptr_map": {
      "d": "d_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define TZNAME_MAX 10\n\nint main() {\n    char (*p)[N];\n    char arr_d[TZNAME_MAX];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume((*p)[k] != 0 && (*p)[k] != '>');\n    }\n\n    while (i < N && (*p)[i] != 0 && (*p)[i] != '>') {\n        __CPROVER_assert(i < TZNAME_MAX, \"Array write within bounds\");\n\n        if (i < TZNAME_MAX) {\n            arr_d[i] = (*p)[i];\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/__tz.c",
    "line": 101,
    "column": 3,
    "source_code": "for (i=0; ((*p)[i]|32)-'a'<26U; i++)\n\t\t\tif (i<TZNAME_MAX) d[i] = (*p)[i];",
    "abstract_code": "for (i=0; ((*p)[i]|32)-'a'<26U; i++)\n\t\t\tif (i<TZNAME_MAX) arr_d[i] = (*p)[i];",
    "ptr_map": {
      "d": "d_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define TZNAME_MAX 50\n\nint main() {\n    char p[N];\n    char arr_d[TZNAME_MAX];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(((p[k] | 32) - 'a') < 26U || p[k] == 0);\n    }\n\n    while (i < N && ((p[i] | 32) - 'a') < 26U) {\n        __CPROVER_assert(i < N, \"Loop index within p bounds\");\n        if (i < TZNAME_MAX) {\n            __CPROVER_assert(i < TZNAME_MAX, \"Loop index within arr_d bounds\");\n            arr_d[i] = p[i];\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/time/__tz.c",
    "line": 141,
    "column": 2,
    "source_code": "for (i=0; i<5; i++) r0[i] = r1[i] = 0;",
    "abstract_code": "for (i=0; i<5; i++) arr_r0[i] = arr_r1[i] = 0;",
    "ptr_map": {
      "r1": "r1_idx",
      "r0": "r0_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 5\n\nint main() {\n    int arr_r0[N];\n    int arr_r1[N];\n    size_t i = 0;\n\n    while (i < N) {\n        __CPROVER_assert(i < N, \"Loop index within bounds for arr_r0\");\n        __CPROVER_assert(i < N, \"Loop index within bounds for arr_r1\");\n        arr_r0[i] = 0;\n        arr_r1[i] = 0;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/sched/sched_cpucount.c",
    "line": 8,
    "column": 25,
    "source_code": "for (j=0; j<8; j++)\n\t\tif (p[i] & (1<<j)) cnt++;",
    "abstract_code": "for (j=0; j<8; j++)\n\t\tif (arr_p[i] & (1<<j)) cnt++;",
    "ptr_map": {
      "p": "p_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define SIZE 8\n\nint main() {\n    unsigned char arr_p[N];\n    int cnt = 0;\n    int i = 0;\n    int j;\n\n    __CPROVER_assume(i >= 0 && i < N);\n\n    for (j = 0; j < SIZE; j++) {\n        __CPROVER_assert(cnt >= 0 && cnt <= j, \"Loop invariant violated\");\n        if (arr_p[i] & (1 << j)) {\n            cnt++;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/malloc/mallocng/malloc.c",
    "line": 185,
    "column": 3,
    "source_code": "while (i<2 && 4*small_cnt_tab[sc][i] > usage)\n\t\t\ti++;",
    "abstract_code": "while (i<2 && 4arr_small_cnt_tab[small_cnt_tab_idx][sc][i] > usage)\n\t\t\ti++;",
    "ptr_map": {
      "small_cnt_tab": "small_cnt_tab_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define USAGE 100\n\nint main() {\n    int small_cnt_tab_idx[N][N][2];\n    int sc = 0;\n    int usage = USAGE;\n    int i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (int k = 0; k < N; ++k) {\n        for (int m = 0; m < N; ++m) {\n            __CPROVER_assume(4 * small_cnt_tab_idx[k][m][0] <= usage);\n            __CPROVER_assume(4 * small_cnt_tab_idx[k][m][1] <= usage);\n        }\n    }\n\n    while (i < 2 && 4 * small_cnt_tab_idx[sc][i] > usage) {\n        __CPROVER_assert(i >= 0 && i < 2, \"Loop index within bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/malloc/mallocng/malloc.c",
    "line": 270,
    "column": 3,
    "source_code": "for (int i=0; i<=cnt; i++)\n\t\t\tp[UNIT+i*size-4] = 0;",
    "abstract_code": "for (int i=0; i<=cnt; i++)\n\t\t\tarr_p[UNIT+i*size-4] = 0;",
    "ptr_map": {
      "p": "p_idx"
    },
    "invariant": "#include <stddef.h>\n#define UNIT 8\n#define N 100\n\nint main() {\n    int cnt;\n    int size;\n    int arr_p[N];\n    int p_idx;\n\n    __CPROVER_assume(cnt >= 0 && cnt < N);\n    __CPROVER_assume(size > 0);\n    __CPROVER_assume(UNIT + cnt * size - 4 < N);\n    __CPROVER_assume(UNIT - 4 >= 0);\n\n    for (int i = 0; i <= cnt; i++) {\n        __CPROVER_assert(UNIT + i * size - 4 >= 0 && UNIT + i * size - 4 < N, \"Array bounds check\");\n        arr_p[UNIT + i * size - 4] = 0;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/stdlib/ecvt.c",
    "line": 14,
    "column": 2,
    "source_code": "for (j=0; tmp[i]!='e'; j+=(tmp[i++]!='.'))\n\t\tbuf[j] = tmp[i];",
    "abstract_code": "for (j=0; arr_tmp[i]!='e'; j+=(arr_tmp[i++]!='.'))\n\t\tarr_buf[j] = arr_tmp[i];",
    "ptr_map": {
      "buf": "buf_idx",
      "tmp": "tmp_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_tmp[N];\n    char arr_buf[N];\n    size_t i = 0;\n    size_t j = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_tmp[k] != 0);\n    }\n\n    while (i < N && arr_tmp[i] != 'e') {\n        __CPROVER_assert(j < N, \"Write index out of bounds\");\n        __CPROVER_assert(i < N, \"Read index out of bounds\");\n\n        arr_buf[j] = arr_tmp[i];\n        \n        if (arr_tmp[i] != '.') {\n            j++;\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/stdlib/qsort.c",
    "line": 173,
    "column": 2,
    "source_code": "for(lp[0]=lp[1]=width, i=2; (lp[i]=lp[i-2]+lp[i-1]+width) < size; i++);\n",
    "abstract_code": "for(arr_lp[0]=arr_lp[1]=width, i=2; (arr_lp[i]=arr_lp[i-2]+arr_lp[i-1]+width) < size; i++);\n",
    "ptr_map": {
      "lp": "lp_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_lp[N];\n    size_t width, size;\n    size_t i;\n\n    __CPROVER_assume(N > 2);\n    __CPROVER_assume(width > 0 && size > 0);\n\n    arr_lp[0] = width;\n    arr_lp[1] = width;\n    i = 2;\n\n    while (i < N && (arr_lp[i] = arr_lp[i-2] + arr_lp[i-1] + width) < size) {\n        __CPROVER_assert(i >= 2 && i < N, \"Loop index within bounds\");\n        __CPROVER_assert(arr_lp[i] == arr_lp[i-2] + arr_lp[i-1] + width, \"Recurrence relation holds\");\n        i++;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/regex/glob.c",
    "line": 43,
    "column": 2,
    "source_code": "while (pos+1 < PATH_MAX && *pat=='/') buf[pos++] = *pat++;",
    "abstract_code": "while (pos+1 < PATH_MAX && *pat=='/') arr_buf[pos++] = *pat++;",
    "ptr_map": {
      "buf": "buf_idx"
    },
    "invariant": "#include <stddef.h>\n#define PATH_MAX 4096\n\nint main() {\n    char arr_buf[PATH_MAX];\n    char pat[PATH_MAX];\n    size_t pos = 0;\n    size_t pat_idx = 0;\n\n    __CPROVER_assume(pat_idx < PATH_MAX);\n    __CPROVER_assume(pat[pat_idx] == '/');\n\n    while (pos + 1 < PATH_MAX && pat[pat_idx] == '/') {\n        __CPROVER_assert(pos < PATH_MAX, \"arr_buf write index within bounds\");\n        __CPROVER_assert(pat_idx < PATH_MAX, \"pat read index within bounds\");\n        __CPROVER_assert(pos == pat_idx, \"pos and pat_idx remain synchronized\");\n\n        arr_buf[pos] = pat[pat_idx];\n        pos++;\n        pat_idx++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/glob.c",
    "line": 49,
    "column": 2,
    "source_code": "for (; pat[i]!='*' && pat[i]!='?' && (!in_bracket || pat[i]!=']'); i++) {\n\t\tif (!pat[i]) {\n\t\t\tif (overflow) return 0;\n\t\t\tpat += i;\n\t\t\tpos += j;\n\t\t\ti = j = 0;\n\t\t\tbreak;\n\t\t} else if (pat[i] == '[') {\n\t\t\tin_bracket = 1;\n\t\t} else if (pat[i] == '\\\\' && !(flags & GLOB_NOESCAPE)) {\n\t\t\t/* Backslashes inside a bracket are (at least by\n\t\t\t * our interpretation) non-special, so if next\n\t\t\t * char is ']' we have a complete expression. */\n\t\t\tif (in_bracket && pat[i+1]==']') break;\n\t\t\t/* Unpaired final backslash never matches. */\n\t\t\tif (!pat[i+1]) return 0;\n\t\t\ti++;\n\t\t}\n\t\tif (pat[i] == '/') {\n\t\t\tif (overflow) return 0;\n\t\t\tin_bracket = 0;\n\t\t\tpat += i+1;\n\t\t\ti = -1;\n\t\t\tpos += j+1;\n\t\t\tj = -1;\n\t\t}\n\t\t/* Only store a character if it fits in the buffer, but if\n\t\t * a potential bracket expression is open, the overflow\n\t\t * must be remembered and handled later only if the bracket\n\t\t * is unterminated (and thereby a literal), so as not to\n\t\t * disallow long bracket expressions with short matches. */\n\t\tif (pos+(j+1) < PATH_MAX) {\n\t\t\tbuf[pos+j++] = pat[i];\n\t\t} else if (in_bracket) {\n\t\t\toverflow = 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t/* If we consume any new components, the caller-passed type\n\t\t * or dummy type from above is no longer valid. */\n\t\ttype = 0;\n\t}\n",
    "abstract_code": "for (; arr_pat[i]!='*' && arr_pat[i]!='?' && (!in_bracket || arr_pat[i]!=']'); i++) {\n\t\tif (!arr_pat[i]) {\n\t\t\tif (overflow) return 0;\n\t\t\tpat += i;\n\t\t\tpos += j;\n\t\t\ti = j = 0;\n\t\t\tbreak;\n\t\t} else if (arr_pat[i] == '[') {\n\t\t\tin_bracket = 1;\n\t\t} else if (arr_pat[i] == '\\\\' && !(flags & GLOB_NOESCAPE)) {\n\t\t\t/* Backslashes inside a bracket are (at least by\n\t\t\t * our interpretation) non-special, so if next\n\t\t\t * char is ']' we have a complete expression. */\n\t\t\tif (in_bracket && arr_pat[i+1]==']') break;\n\t\t\t/* Unpaired final backslash never matches. */\n\t\t\tif (!arr_pat[i+1]) return 0;\n\t\t\ti++;\n\t\t}\n\t\tif (arr_pat[i] == '/') {\n\t\t\tif (overflow) return 0;\n\t\t\tin_bracket = 0;\n\t\t\tpat += i+1;\n\t\t\ti = -1;\n\t\t\tpos += j+1;\n\t\t\tj = -1;\n\t\t}\n\t\t/* Only store a character if it fits in the buffer, but if\n\t\t * a potential bracket expression is open, the overflow\n\t\t * must be remembered and handled later only if the bracket\n\t\t * is unterminated (and thereby a literal), so as not to\n\t\t * disallow long bracket expressions with short matches. */\n\t\tif (pos+(j+1) < PATH_MAX) {\n\t\t\tarr_buf[pos+j++] = arr_pat[i];\n\t\t} else if (in_bracket) {\n\t\t\toverflow = 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\t/* If we consume any new components, the caller-passed type\n\t\t * or dummy type from above is no longer valid. */\n\t\ttype = 0;\n\t}\n",
    "ptr_map": {
      "pat": "pat_idx",
      "buf": "buf_idx"
    },
    "invariant": "```c\n#include <stddef.h>\n#include <limits.h>\n\n#define N 100\n#define PATH_MAX 4096\n#define GLOB_NOESCAPE 1\n\nint main() {\n    char arr_pat[N];\n    char arr_buf[PATH_MAX];\n    int i = 0, j = 0, pos = 0;\n    int in_bracket = 0, overflow = 0, flags = 0;\n    int type = 0;\n    int pat_idx = 0, buf_idx = 0;\n\n    __CPROVER_assume(N > 0 && PATH_MAX > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_pat[k] >= 0 && arr_pat[k] <= 127);\n    }\n    for (size_t k = 0; k < PATH_MAX; k++) {\n        arr_buf[k] = 0;\n    }\n\n    while (i < N && arr_pat[i] != '*' && arr_pat[i] != '?' && (!in_bracket || arr_pat[i] != ']')) {\n        __CPROVER_assert(\n            (i >= 0 && i < N) &&\n            (j >= 0 && j <= PATH_MAX) &&\n            (pos >= 0 && pos < PATH_MAX) &&\n            (pos + j >= 0 && pos + j <= PATH_MAX) &&\n            (in_bracket == 0 || in_bracket == 1) &&\n            (overflow == 0 || overflow == 1) &&\n            (type == 0),\n            \"Loop invariant violated\"\n        );\n\n        if (!arr_pat[i]) {\n            if (overflow) return 0;\n            pat_idx += i;\n            pos += j;\n            i = j = 0;\n            break;\n        } else if (arr_pat[i] == '[') {\n            in_bracket = 1;\n        } else if (arr_pat[i] == '\\\\' && !(flags & GLOB_NOESCAPE)) {\n            if (in_bracket && i + 1 < N && arr_pat[i + 1] == ']') break;\n            if (i + 1 >= N || !arr_pat[i + 1]) return 0;\n            i++;\n        }\n        if (arr_pat[i] == '/') {\n            if (overflow) return 0;\n            in_bracket = 0;\n            pat_idx += i + 1;\n            i = -1;\n            pos += j + 1;\n            j = -1;\n        }\n        if (pos + (j + 1) < PATH_MAX) {\n            if (pos + j >= 0 && pos + j < PATH_MAX) {\n                arr_buf[pos + j] = arr_pat[i];\n            }\n            j++;\n        } else if (in_bracket) {\n            overflow = 1;\n        } else {\n            return 0;\n        }\n        type = 0;\n        i++;\n    }\n    return 0;\n}\n```"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/regex/glob.c",
    "line": 217,
    "column": 2,
    "source_code": "while (i < PATH_MAX - 2 && *home)\n\t\tbuf[i++] = *home++;",
    "abstract_code": "while (i < PATH_MAX - 2 && *home)\n\t\tarr_buf[i++] = *home++;",
    "ptr_map": {
      "buf": "buf_idx"
    },
    "invariant": "#include <stddef.h>\n#define PATH_MAX 1024\n\nint main() {\n    char arr_buf[PATH_MAX];\n    char home[PATH_MAX];\n    size_t i = 0;\n    size_t home_idx = 0;\n\n    __CPROVER_assume(home_idx < PATH_MAX);\n    __CPROVER_assume(home[home_idx] != 0);\n\n    while (i < PATH_MAX - 2 && home[home_idx] != 0) {\n        __CPROVER_assert(i < PATH_MAX, \"Loop invariant: index within bounds\");\n        __CPROVER_assert(home_idx < PATH_MAX, \"Loop invariant: source index within bounds\");\n\n        arr_buf[i] = home[home_idx];\n        i++;\n        home_idx++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regexec.c",
    "line": 103,
    "column": 3,
    "source_code": "for (i = 0; i < num_tags; i++)\n    {\n      if (tag_directions[i] == TRE_TAG_MINIMIZE)\n\t{\n\t  if (t1[i] < t2[i])\n\t    return 1;\n\t  if (t1[i] > t2[i])\n\t    return 0;\n\t}\n      else\n\t{\n\t  if (t1[i] > t2[i])\n\t    return 1;\n\t  if (t1[i] < t2[i])\n\t    return 0;\n\t}\n    }\n",
    "abstract_code": "for (i = 0; i < num_tags; i++)\n    {\n      if (arr_tag_directions[i] == TRE_TAG_MINIMIZE)\n\t{\n\t  if (arr_t1[i] < arr_t2[i])\n\t    return 1;\n\t  if (arr_t1[i] > arr_t2[i])\n\t    return 0;\n\t}\n      else\n\t{\n\t  if (arr_t1[i] > arr_t2[i])\n\t    return 1;\n\t  if (arr_t1[i] < arr_t2[i])\n\t    return 0;\n\t}\n    }\n",
    "ptr_map": {
      "t1": "t1_idx",
      "tag_directions": "tag_directions_idx",
      "t2": "t2_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define TRE_TAG_MINIMIZE 1\n\nint main() {\n    size_t num_tags = N;\n    int arr_tag_directions[N];\n    int arr_t1[N];\n    int arr_t2[N];\n    size_t i = 0;\n\n    __CPROVER_assume(num_tags <= N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_tag_directions[k] == 0 || arr_tag_directions[k] == TRE_TAG_MINIMIZE);\n    }\n\n    while (i < num_tags) {\n        __CPROVER_assert(\n            (i == 0) ||\n            (arr_tag_directions[i-1] == TRE_TAG_MINIMIZE && arr_t1[i-1] == arr_t2[i-1]) ||\n            (arr_tag_directions[i-1] != TRE_TAG_MINIMIZE && arr_t1[i-1] == arr_t2[i-1]),\n            \"Loop invariant violated\"\n        );\n\n        if (arr_tag_directions[i] == TRE_TAG_MINIMIZE) {\n            if (arr_t1[i] < arr_t2[i]) {\n                return 1;\n            }\n            if (arr_t1[i] > arr_t2[i]) {\n                return 0;\n            }\n        } else {\n            if (arr_t1[i] > arr_t2[i]) {\n                return 1;\n            }\n            if (arr_t1[i] < arr_t2[i]) {\n                return 0;\n            }\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/regex/regexec.c",
    "line": 397,
    "column": 7,
    "source_code": "while (*tag_i >= 0)\n\t\t      {\n\t\t\tif (*tag_i < num_tags)\n\t\t\t  tmp_tags[*tag_i] = pos;\n\t\t\ttag_i++;\n\t\t      }\n",
    "abstract_code": "while (*tag_i >= 0)\n\t\t      {\n\t\t\tif (*tag_i < num_tags)\n\t\t\t  arr_tmp_tags[*tag_i] = pos;\n\t\t\ttag_i++;\n\t\t      }\n",
    "ptr_map": {
      "tmp_tags": "tmp_tags_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int tag_i_arr[N];\n    int *tag_i = tag_i_arr;\n    int arr_tmp_tags[N];\n    int num_tags = N;\n    int pos = 42;\n    \n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(tag_i_arr[k] >= -1);\n    }\n    \n    while (*tag_i >= 0) {\n        __CPROVER_assert(tag_i >= tag_i_arr && tag_i < tag_i_arr + N, \"tag_i within bounds\");\n        __CPROVER_assert(*tag_i >= 0 && *tag_i < num_tags, \"*tag_i valid index for arr_tmp_tags\");\n        \n        if (*tag_i < num_tags) {\n            arr_tmp_tags[*tag_i] = pos;\n        }\n        tag_i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regexec.c",
    "line": 444,
    "column": 10,
    "source_code": "for (i = 0; i < num_tags; i++)\n\t\t\t\tmatch_tags[i] = tmp_tags[i];",
    "abstract_code": "for (i = 0; i < num_tags; i++)\n\t\t\t\tarr_match_tags[i] = arr_tmp_tags[i];",
    "ptr_map": {
      "match_tags": "match_tags_idx",
      "tmp_tags": "tmp_tags_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_match_tags[N];\n    size_t arr_tmp_tags[N];\n    size_t num_tags;\n    size_t i = 0;\n\n    __CPROVER_assume(num_tags <= N);\n\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_tmp_tags[k] < 1000);\n    }\n\n    while (i < num_tags) {\n        __CPROVER_assert(i < N, \"Loop index within bounds for arr_match_tags\");\n        __CPROVER_assert(i < N, \"Loop index within bounds for arr_tmp_tags\");\n\n        arr_match_tags[i] = arr_tmp_tags[i];\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regexec.c",
    "line": 732,
    "column": 5,
    "source_code": "for (; *next_tags >= 0; next_tags++)\n      tags[*next_tags] = pos;",
    "abstract_code": "for (; *next_tags >= 0; next_tags++)\n      arr_tags[*next_tags] = pos;",
    "ptr_map": {
      "tags": "tags_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_tags[N];\n    int next_tags_arr[N];\n    int pos = 5;\n    int *next_tags = next_tags_arr;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(next_tags_arr[k] >= -1);\n        __CPROVER_assume(next_tags_arr[k] < N);\n    }\n\n    while (*next_tags >= 0) {\n        __CPROVER_assert(*next_tags >= 0 && *next_tags < N, \"Array index bounds\");\n        arr_tags[*next_tags] = pos;\n        next_tags++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/regex/regexec.c",
    "line": 868,
    "column": 6,
    "source_code": "while (*next_tags >= 0)\n\t      tags[*next_tags++] = pos;",
    "abstract_code": "while (*next_tags >= 0)\n\t      arr_tags[*next_tags++] = pos;",
    "ptr_map": {
      "tags": "tags_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_tags[N];\n    int next_tags[N];\n    int pos = 0;\n    int *ptr = next_tags;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(next_tags[k] >= -1 && next_tags[k] < N);\n    }\n\n    while (*ptr >= 0) {\n        __CPROVER_assert(*ptr >= 0 && *ptr < N, \"Array index within bounds\");\n        arr_tags[*ptr] = pos;\n        ptr++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regcomp.c",
    "line": 1275,
    "column": 6,
    "source_code": "for (i = 0; regset[i] >= 0; i++);\n",
    "abstract_code": "for (i = 0; arr_regset[i] >= 0; i++);\n",
    "ptr_map": {
      "regset": "regset_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_regset[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_regset[k] >= -1);\n    }\n\n    while (i < N && arr_regset[i] >= 0) {\n        __CPROVER_assert(i < N, \"Loop index within bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regcomp.c",
    "line": 1280,
    "column": 6,
    "source_code": "for (i = 0; parents[i] >= 0; i++);\n",
    "abstract_code": "for (i = 0; arr_parents[i] >= 0; i++);\n",
    "ptr_map": {
      "parents": "parents_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_parents[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_parents[k] >= -1);\n    }\n\n    while (i < N && arr_parents[i] >= 0) {\n        __CPROVER_assert(\n            i < N,\n            \"Loop invariant: index within bounds\"\n        );\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regcomp.c",
    "line": 1295,
    "column": 8,
    "source_code": "for (i = 0; regset[i] >= 0; i++);\n",
    "abstract_code": "for (i = 0; arr_regset[i] >= 0; i++);\n",
    "ptr_map": {
      "regset": "regset_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_regset[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_regset[k] >= -1);\n    }\n\n    while (i < N && arr_regset[i] >= 0) {\n        __CPROVER_assert(i < N, \"Loop index within bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regcomp.c",
    "line": 1301,
    "column": 5,
    "source_code": "for (i = 0; parents[i] >= 0; i++);\n",
    "abstract_code": "for (i = 0; arr_parents[i] >= 0; i++);\n",
    "ptr_map": {
      "parents": "parents_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_parents[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_parents[k] >= -1);\n    }\n\n    while (i < N && arr_parents[i] >= 0) {\n        __CPROVER_assert(i < N, \"Loop index within bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regcomp.c",
    "line": 1313,
    "column": 9,
    "source_code": "for (i = 0; parents[i] >= 0; i++)\n\t\t\tp[i] = parents[i];",
    "abstract_code": "for (i = 0; arr_parents[i] >= 0; i++)\n\t\t\tarr_p[i] = arr_parents[i];",
    "ptr_map": {
      "p": "p_idx",
      "parents": "parents_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_parents[N];\n    int arr_p[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_parents[k] >= -1);\n    }\n\n    while (i < N && arr_parents[i] >= 0) {\n        __CPROVER_assert(i < N, \"Write index within bounds\");\n        __CPROVER_assert(i < N, \"Read index within bounds\");\n\n        arr_p[i] = arr_parents[i];\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regcomp.c",
    "line": 1535,
    "column": 8,
    "source_code": "for (i = 0; parents[i] >= 0; i++);\n",
    "abstract_code": "for (i = 0; arr_parents[i] >= 0; i++);\n",
    "ptr_map": {
      "parents": "parents_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_parents[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_parents[k] >= -1);\n    }\n\n    while (i < N && arr_parents[i] >= 0) {\n        __CPROVER_assert(i < N, \"Loop invariant: index within bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/regex/regcomp.c",
    "line": 2094,
    "column": 4,
    "source_code": "for (i = 0; i < num_tags; i++)\n\t    new_tags[j + i] = tags[i];",
    "abstract_code": "for (i = 0; i < num_tags; i++)\n\t    arr_new_tags[j + i] = arr_tags[i];",
    "ptr_map": {
      "new_tags": "new_tags_idx",
      "tags": "tags_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_new_tags[N];\n    size_t arr_tags[N];\n    size_t num_tags, j, i;\n\n    __CPROVER_assume(num_tags > 0 && num_tags <= N);\n    __CPROVER_assume(j < N);\n    __CPROVER_assume(j + num_tags <= N);\n\n    for (size_t k = 0; k < num_tags; k++) {\n        __CPROVER_assume(arr_tags[k] < 1000);\n    }\n\n    i = 0;\n    while (i < num_tags) {\n        __CPROVER_assert(i < num_tags && j + i < N, \"Loop invariant: index bounds\");\n        arr_new_tags[j + i] = arr_tags[i];\n        i++;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/regex/fnmatch.c",
    "line": 72,
    "column": 5,
    "source_code": "while (k<m && pat[k] && (pat[k-1]!=z || pat[k]!=']')) k++;",
    "abstract_code": "while (k<m && arr_pat[k] && (arr_pat[k-1]!=z || arr_pat[k]!=']')) k++;",
    "ptr_map": {
      "pat": "pat_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t m = N;\n    char arr_pat[N];\n    size_t k = 1;\n    char z = 'a';\n\n    __CPROVER_assume(m > 1 && k < m);\n    for (size_t idx = 0; idx < N; idx++) {\n        __CPROVER_assume(arr_pat[idx] >= 0 && arr_pat[idx] <= 127);\n    }\n\n    while (k < m && arr_pat[k] && (arr_pat[k-1] != z || arr_pat[k] != ']')) {\n        __CPROVER_assert(k < m && k >= 1, \"Loop invariant: array access within bounds\");\n        k++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/regex/fnmatch.c",
    "line": 140,
    "column": 4,
    "source_code": "while (p[-1]!=z || p[0]!=']') p++;",
    "abstract_code": "while (arr_p[-1]!=z || arr_p[0]!=']') p_idx++;",
    "ptr_map": {
      "p": "p_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_p[N];\n    size_t p_idx = 1;\n    char z = 'a';\n\n    __CPROVER_assume(N > 2);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_p[k] != 0);\n    }\n\n    while (p_idx < N && (arr_p[p_idx - 1] != z || arr_p[p_idx] != ']')) {\n        __CPROVER_assert(p_idx >= 1 && p_idx < N, \"Loop invariant: index in bounds\");\n        p_idx++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/locale/iconv.c",
    "line": 212,
    "column": 2,
    "source_code": "for (;;) {\n\t\ti = nel/2;\n\t\tj = rev_jis[b+i];\n\t\td = jis0208[j/256][j%256];\n\t\tif (d==c) return j + 0x2121;\n\t\telse if (nel == 1) return 0;\n\t\telse if (c < d)\n\t\t\tnel /= 2;\n\t\telse {\n\t\t\tb += i;\n\t\t\tnel -= nel/2;\n\t\t}\n\t}\n",
    "abstract_code": "for (;;) {\n\t\ti = nel/2;\n\t\tj = arr_rev_jis[b+i];\n\t\td = arr_jis0208[j/256][j%256];\n\t\tif (d==c) return j + 0x2121;\n\t\telse if (nel == 1) return 0;\n\t\telse if (c < d)\n\t\t\tnel /= 2;\n\t\telse {\n\t\t\tb += i;\n\t\t\tnel -= nel/2;\n\t\t}\n\t}\n",
    "ptr_map": {
      "jis0208": "jis0208_idx",
      "rev_jis": "rev_jis_idx"
    },
    "invariant": "#include <stddef.h>\n#include <assert.h>\n\n#define N_REV_JIS 100\n#define JIS0208_ROWS 256\n#define JIS0208_COLS 256\n\nint main() {\n    unsigned short arr_rev_jis[N_REV_JIS];\n    unsigned short arr_jis0208[JIS0208_ROWS][JIS0208_COLS];\n    unsigned short c = __CPROVER_nondet_ushort();\n    unsigned short nel = __CPROVER_nondet_ushort();\n    unsigned short b = __CPROVER_nondet_ushort();\n    unsigned short i, j, d;\n\n    __CPROVER_assume(nel > 0 && nel <= N_REV_JIS);\n    __CPROVER_assume(b < N_REV_JIS);\n    __CPROVER_assume(b + nel <= N_REV_JIS);\n    for (size_t k = 0; k < N_REV_JIS; k++) {\n        __CPROVER_assume(arr_rev_jis[k] < JIS0208_ROWS * JIS0208_COLS);\n    }\n    for (size_t r = 0; r < JIS0208_ROWS; r++) {\n        for (size_t col = 0; col < JIS0208_COLS; col++) {\n            __CPROVER_assume(arr_jis0208[r][col] <= 0xFFFF);\n        }\n    }\n\n    while (1) {\n        i = nel / 2;\n        __CPROVER_assume(b + i < N_REV_JIS);\n        j = arr_rev_jis[b + i];\n        __CPROVER_assume(j / 256 < JIS0208_ROWS && j % 256 < JIS0208_COLS);\n        d = arr_jis0208[j / 256][j % 256];\n\n        __CPROVER_assert(b >= 0 && b + nel <= N_REV_JIS, \"Array bounds invariant\");\n        __CPROVER_assert(nel > 0, \"Positive nel invariant\");\n\n        if (d == c) {\n            __CPROVER_assert(j + 0x2121 <= 0xFFFF, \"Return value bounds\");\n            return 0;\n        } else if (nel == 1) {\n            return 0;\n        } else if (c < d) {\n            nel /= 2;\n        } else {\n            b += i;\n            nel -= nel / 2;\n        }\n    }\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/locale/iconv.c",
    "line": 430,
    "column": 7,
    "source_code": "for (int j=0; j<190; j++)\n\t\t\t\t\t\t\tif (gb18030[i][j]-d <= c-d)\n\t\t\t\t\t\t\t\tk++;",
    "abstract_code": "for (int j=0; j<190; j++)\n\t\t\t\t\t\t\tif (arr_gb18030[i][j]-d <= c-d)\n\t\t\t\t\t\t\t\tk++;",
    "ptr_map": {
      "gb18030": "gb18030_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 190\n#define I_MAX 100\n\nint main() {\n    int arr_gb18030[I_MAX][N];\n    int i, d, c, k = 0;\n    int j;\n\n    __CPROVER_assume(i >= 0 && i < I_MAX);\n    __CPROVER_assume(d >= 0);\n    __CPROVER_assume(c >= 0);\n\n    for (j = 0; j < N; j++) {\n        __CPROVER_assert(j >= 0 && j < N, \"Index bounds for j\");\n        __CPROVER_assert(i >= 0 && i < I_MAX, \"Index bounds for i\");\n        \n        if (arr_gb18030[i][j] - d <= c - d) {\n            k++;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/locale/iconv.c",
    "line": 510,
    "column": 7,
    "source_code": "for (int j=0; j<94; j++)\n\t\t\t\t\t\t\tif (ksc[i][j]-d <= c-d)\n\t\t\t\t\t\t\t\tk++;",
    "abstract_code": "for (int j=0; j<94; j++)\n\t\t\t\t\t\t\tif (arr_ksc[i][j]-d <= c-d)\n\t\t\t\t\t\t\t\tk++;",
    "ptr_map": {
      "ksc": "ksc_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 94\n\nint main() {\n    int arr_ksc[100][N];\n    int i = __CPROVER_nondet_int();\n    int d = __CPROVER_nondet_int();\n    int c = __CPROVER_nondet_int();\n    int k = 0;\n    int j = 0;\n\n    __CPROVER_assume(i >= 0 && i < 100);\n    __CPROVER_assume(d >= 0);\n    __CPROVER_assume(c >= 0);\n\n    while (j < N) {\n        __CPROVER_assert(k >= 0 && k <= j, \"Loop invariant: k counts matches up to j\");\n        if (arr_ksc[i][j] - d <= c - d) {\n            k++;\n        }\n        j++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/passwd/getgrent_a.c",
    "line": 56,
    "column": 3,
    "source_code": "for (s=mems, i=0; *s; s++)\n\t\t\tif (*s==',') *s++ = 0, mem[0][++i] = s;",
    "abstract_code": "for (s=mems, i=0; *s; s++)\n\t\t\tif (*s==',') *s++ = 0, arr_mem[0][++i] = s;",
    "ptr_map": {
      "mem": "mem_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char mems[N];\n    char *arr_mem[1][N];\n    char *s;\n    int i;\n    \n    __CPROVER_assume(N > 1);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(mems[k] == 0 || mems[k] == ',');\n    }\n    \n    s = mems;\n    i = 0;\n    arr_mem[0][0] = s;\n    \n    while (*s != 0) {\n        __CPROVER_assert(\n            (i >= 0) &&\n            (i < N) &&\n            (s >= mems) &&\n            (s < mems + N) &&\n            (arr_mem[0][i] >= mems) &&\n            (arr_mem[0][i] < mems + N),\n            \"Loop invariant violated\"\n        );\n        \n        if (*s == ',') {\n            *s = 0;\n            s++;\n            __CPROVER_assume(*s != 0);\n            i++;\n            __CPROVER_assume(i < N);\n            arr_mem[0][i] = s;\n        }\n        s++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/passwd/getgrouplist.c",
    "line": 66,
    "column": 3,
    "source_code": "for(i=0; i < resp[INITGRNGRPS]; i++) {\n\t\t\tif (nscdbuf[i] != gid)\n\t\t\t\tif(++n <= nlim) *groups++ = nscdbuf[i];\n\t\t}\n",
    "abstract_code": "for(i=0; i < arr_resp[INITGRNGRPS]; i++) {\n\t\t\tif (arr_nscdbuf[i] != gid)\n\t\t\t\tif(++n <= nlim) *groups++ = arr_nscdbuf[i];\n\t\t}\n",
    "ptr_map": {
      "nscdbuf": "nscdbuf_idx",
      "resp": "resp_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define INITGRNGRPS 0\n\nint main() {\n    size_t arr_resp[N];\n    size_t arr_nscdbuf[N];\n    size_t gid = 10;\n    size_t n = 0;\n    size_t nlim = N;\n    size_t groups[N];\n    size_t *groups_ptr = groups;\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    __CPROVER_assume(arr_resp[INITGRNGRPS] <= N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_nscdbuf[k] < 1000);\n    }\n\n    while (i < arr_resp[INITGRNGRPS]) {\n        __CPROVER_assert(\n            n <= i,\n            \"Loop invariant violated: n cannot exceed processed elements\"\n        );\n\n        if (arr_nscdbuf[i] != gid) {\n            if (n + 1 <= nlim) {\n                *groups_ptr = arr_nscdbuf[i];\n                groups_ptr++;\n                n++;\n            }\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/passwd/getgr_a.c",
    "line": 129,
    "column": 4,
    "source_code": "for (ptr = mem[0][0], i = 0; ptr != mem[0][0]+grlist_len; ptr++)\n\t\t\t\tif (!*ptr) mem[0][++i] = ptr+1;",
    "abstract_code": "for (ptr = arr_mem[0][0], i = 0; ptr != arr_mem[0][0]+grlist_len; ptr++)\n\t\t\t\tif (!*ptr) arr_mem[0][++i] = ptr+1;",
    "ptr_map": {
      "mem": "mem_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define grlist_len 50\n\nint main() {\n    char *arr_mem[1][N];\n    char buffer[N];\n    char *ptr;\n    int i = 0;\n\n    __CPROVER_assume(N > grlist_len);\n    for (size_t k = 0; k < N; k++) {\n        buffer[k] = __CPROVER_nondet_char();\n        __CPROVER_assume(k < grlist_len || buffer[k] != 0);\n    }\n    arr_mem[0][0] = &buffer[0];\n\n    ptr = arr_mem[0][0];\n    i = 0;\n    while (ptr != arr_mem[0][0] + grlist_len) {\n        __CPROVER_assert(\n            i >= 0 && i < N,\n            \"Loop invariant: i within array bounds\"\n        );\n        if (ptr >= arr_mem[0][0] && ptr < arr_mem[0][0] + grlist_len) {\n            if (!*ptr) {\n                i++;\n                __CPROVER_assume(i < N);\n                arr_mem[0][i] = ptr + 1;\n            }\n        }\n        ptr++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/ctype/towctrans.c",
    "line": 44,
    "column": 2,
    "source_code": "while (xn) {\n\t\tunsigned try = exceptions[xb+xn/2][0];\n\t\tif (try == c) {\n\t\t\tr = rules[exceptions[xb+xn/2][1]];\n\t\t\trt = r & 255;\n\t\t\trd = r >> 8;\n\t\t\tif (rt < 2) return c0 + (rd & -(rt^dir));\n\t\t\t/* Hard-coded for the four exceptional titlecase */\n\t\t\treturn c0 + (dir ? -1 : 1);\n\t\t} else if (try > c) {\n\t\t\txn /= 2;\n\t\t} else {\n\t\t\txb += xn/2;\n\t\t\txn -= xn/2;\n\t\t}\n\t}\n",
    "abstract_code": "while (xn) {\n\t\tunsigned try = arr_exceptions[xb+xn/2][0];\n\t\tif (try == c) {\n\t\t\tr = arr_rules[arr_exceptions[xb+xn/2][1]];\n\t\t\trt = r & 255;\n\t\t\trd = r >> 8;\n\t\t\tif (rt < 2) return c0 + (rd & -(rt^dir));\n\t\t\t/* Hard-coded for the four exceptional titlecase */\n\t\t\treturn c0 + (dir ? -1 : 1);\n\t\t} else if (try > c) {\n\t\t\txn /= 2;\n\t\t} else {\n\t\t\txb += xn/2;\n\t\t\txn -= xn/2;\n\t\t}\n\t}\n",
    "ptr_map": {
      "exceptions": "exceptions_idx",
      "rules": "rules_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n\n#define N 100\n#define M 100\n\nint main() {\n    unsigned arr_exceptions[N][2];\n    unsigned arr_rules[M];\n    unsigned c = nondet_uint();\n    unsigned c0 = nondet_uint();\n    unsigned dir = nondet_uint();\n    unsigned xb = 0;\n    unsigned xn = N;\n    unsigned r, rt, rd;\n\n    __CPROVER_assume(N > 0 && M > 0);\n    __CPROVER_assume(xn <= N);\n    for (size_t i = 0; i < N; ++i) {\n        __CPROVER_assume(arr_exceptions[i][0] < 1000);\n        __CPROVER_assume(arr_exceptions[i][1] < M);\n    }\n\n    while (xn) {\n        unsigned mid = xb + xn / 2;\n        __CPROVER_assume(mid < N);\n        unsigned try = arr_exceptions[mid][0];\n\n        __CPROVER_assert(\n            (mid == xb + xn / 2) &&\n            (xb < N) &&\n            (mid < N) &&\n            (xn <= N),\n            \"Loop invariant: indices within bounds and mid computed correctly\"\n        );\n\n        if (try == c) {\n            unsigned idx = arr_exceptions[mid][1];\n            __CPROVER_assume(idx < M);\n            r = arr_rules[idx];\n            rt = r & 255;\n            rd = r >> 8;\n            if (rt < 2) return c0 + (rd & -(rt ^ dir));\n            return c0 + (dir ? -1 : 1);\n        } else if (try > c) {\n            xn /= 2;\n        } else {\n            xb += xn / 2;\n            xn -= xn / 2;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/process/execl.c",
    "line": 16,
    "column": 3,
    "source_code": "for (i=1; i<argc; i++)\n\t\t\targv[i] = va_arg(ap, char *);",
    "abstract_code": "for (i=1; i<argc; i++)\n\t\t\tarr_argv[i] = va_arg(ap, char *);",
    "ptr_map": {
      "argv": "argv_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int argc;\n    char *arr_argv[N];\n    int i;\n\n    __CPROVER_assume(argc > 1 && argc <= N);\n    for (int k = 0; k < N; k++) {\n        arr_argv[k] = NULL;\n    }\n\n    i = 1;\n    while (i < argc) {\n        __CPROVER_assert(i >= 1 && i < N, \"Array index within bounds\");\n        arr_argv[i] = (char *)__CPROVER_nondet_pointer();\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/process/execle.c",
    "line": 17,
    "column": 3,
    "source_code": "for (i=1; i<=argc; i++)\n\t\t\targv[i] = va_arg(ap, char *);",
    "abstract_code": "for (i=1; i<=argc; i++)\n\t\t\tarr_argv[i] = va_arg(ap, char *);",
    "ptr_map": {
      "argv": "argv_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char *arr_argv[N];\n    int argc;\n    int i;\n\n    __CPROVER_assume(argc >= 0 && argc < N);\n    __CPROVER_assume(N > 0);\n\n    i = 1;\n    while (i <= argc) {\n        __CPROVER_assert(i >= 1 && i < N, \"Loop invariant: array index within bounds\");\n        arr_argv[i] = __CPROVER_nondet_char_ptr();\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/process/execlp.c",
    "line": 16,
    "column": 3,
    "source_code": "for (i=1; i<argc; i++)\n\t\t\targv[i] = va_arg(ap, char *);",
    "abstract_code": "for (i=1; i<argc; i++)\n\t\t\tarr_argv[i] = va_arg(ap, char *);",
    "ptr_map": {
      "argv": "argv_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdarg.h>\n\n#define MAX_ARGC 100\n\nint main() {\n    int argc;\n    char *arr_argv[MAX_ARGC];\n    va_list ap;\n    int i;\n\n    __CPROVER_assume(argc >= 1 && argc <= MAX_ARGC);\n    __CPROVER_assume(va_arg(ap, char *) != NULL);\n\n    for (i = 1; i < argc; i++) {\n        __CPROVER_assert(i >= 1 && i < MAX_ARGC, \"Array index within bounds\");\n        arr_argv[i] = va_arg(ap, char *);\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/aio/aio.c",
    "line": 426,
    "column": 23,
    "source_code": "for (int d=0; d<256; d++)\n\t\t\t\t\tmap[a][b][c][d] = 0;",
    "abstract_code": "for (int d=0; d<256; d++)\n\t\t\t\t\tarr_map[a][b][c][d] = 0;",
    "ptr_map": {
      "map": "map_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n\n#define N 256\n#define A_MAX 10\n#define B_MAX 10\n#define C_MAX 10\n\nint main() {\n    uint32_t arr_map[A_MAX][B_MAX][C_MAX][N];\n    int a, b, c;\n\n    __CPROVER_assume(a >= 0 && a < A_MAX);\n    __CPROVER_assume(b >= 0 && b < B_MAX);\n    __CPROVER_assume(c >= 0 && c < C_MAX);\n\n    for (int d = 0; d < N; d++) {\n        __CPROVER_assert(d >= 0 && d < N, \"Loop index within bounds\");\n        arr_map[a][b][c][d] = 0;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/getnameinfo.c",
    "line": 38,
    "column": 2,
    "source_code": "for (i=15; i>=0; i--) {\n\t\t*s++ = xdigits[ip[i]&15]; *s++ = '.';\n\t\t*s++ = xdigits[ip[i]>>4]; *s++ = '.';\n\t}\n",
    "abstract_code": "for (i=15; i>=0; i--) {\n\t\t*s++ = arr_xdigits[arr_ip[i]&15]; *s++ = '.';\n\t\t*s++ = arr_xdigits[arr_ip[i]>>4]; *s++ = '.';\n\t}\n",
    "ptr_map": {
      "xdigits": "xdigits_idx",
      "ip": "ip_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 16\n#define XDIGITS_SIZE 16\n\nint main() {\n    char arr_xdigits[XDIGITS_SIZE];\n    unsigned char arr_ip[N];\n    char s[N * 4];\n    char *ptr = s;\n    int i = 15;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < XDIGITS_SIZE; k++) {\n        __CPROVER_assume(arr_xdigits[k] >= '0' && arr_xdigits[k] <= 'f');\n    }\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_ip[k] >= 0 && arr_ip[k] <= 255);\n    }\n\n    while (i >= 0) {\n        __CPROVER_assert(\n            (ptr - s) == (15 - i) * 4,\n            \"Loop invariant: pointer offset matches processed bytes\"\n        );\n\n        *ptr++ = arr_xdigits[arr_ip[i] & 15];\n        *ptr++ = '.';\n        *ptr++ = arr_xdigits[arr_ip[i] >> 4];\n        *ptr++ = '.';\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/res_mkquery.c",
    "line": 28,
    "column": 3,
    "source_code": "for (j=i; q[j] && q[j] != '.'; j++);\n",
    "abstract_code": "for (j=i; arr_q[j] && arr_q[j] != '.'; j++);\n",
    "ptr_map": {
      "q": "q_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_q[N];\n    size_t i = 0;\n    size_t j = i;\n\n    __CPROVER_assume(i < N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_q[k] == 0 || arr_q[k] == '.');\n    }\n\n    while (j < N && arr_q[j] != 0 && arr_q[j] != '.') {\n        __CPROVER_assert(j >= i && j < N, \"Loop invariant violated\");\n        j++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/dn_comp.c",
    "line": 27,
    "column": 3,
    "source_code": "for (; j<l && s[j]!='.'; j++);\n",
    "abstract_code": "for (; j<l && arr_s[j]!='.'; j++);\n",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_s[N];\n    size_t j = 0;\n    size_t l = N;\n\n    __CPROVER_assume(l <= N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] != 0);\n    }\n\n    while (j < l && arr_s[j] != '.') {\n        __CPROVER_assert(j < l, \"Loop invariant: index within bounds\");\n        j++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/dn_comp.c",
    "line": 88,
    "column": 2,
    "source_code": "for (i=j=0; i<l-bestlen; i+=lens[j++]+1)\n\t\tdst[i] = lens[j];",
    "abstract_code": "for (i=j=0; i<l-bestlen; i+=arr_lens[j++]+1)\n\t\tarr_dst[i] = arr_lens[j];",
    "ptr_map": {
      "dst": "dst_idx",
      "lens": "lens_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define L 50\n#define BESTLEN 10\n\nint main() {\n    size_t arr_dst[N];\n    size_t arr_lens[N];\n    size_t i = 0, j = 0;\n    size_t limit = L - BESTLEN;\n\n    __CPROVER_assume(N > limit && limit > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_lens[k] < limit);\n    }\n\n    while (i < limit) {\n        __CPROVER_assert(j < N && i < N, \"Array bounds safety\");\n        __CPROVER_assert(\n            (j == 0 && i == 0) ||\n            (j > 0 && i == (arr_lens[0] + 1) + (j > 1 ? arr_lens[1] + 1 : 0) + (j > 2 ? arr_lens[2] + 1 : 0) + (j > 3 ? arr_lens[3] + 1 : 0)),\n            \"Loop invariant: i equals cumulative sum of previous lens elements plus j\"\n        );\n\n        arr_dst[i] = arr_lens[j];\n        i += arr_lens[j++] + 1;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/res_msend.c",
    "line": 181,
    "column": 3,
    "source_code": "for (i=0; i<nqueries && alens[i]>0; i++);\n",
    "abstract_code": "for (i=0; i<nqueries && arr_alens[i]>0; i++);\n",
    "ptr_map": {
      "alens": "alens_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_alens[N];\n    size_t nqueries = N;\n    size_t i = 0;\n\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_alens[k] < 1000);\n    }\n\n    while (i < nqueries && arr_alens[i] > 0) {\n        __CPROVER_assert(i < N, \"Loop invariant: array access within bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/res_msend.c",
    "line": 220,
    "column": 4,
    "source_code": "for (i=next; i<nqueries && (\n\t\t\t\tanswers[next][0] != queries[i][0] ||\n\t\t\t\tanswers[next][1] != queries[i][1] ); i++);\n",
    "abstract_code": "for (i=next; i<nqueries && (\n\t\t\t\tarr_answers[next][0] != arr_queries[i][0] ||\n\t\t\t\tarr_answers[next][1] != arr_queries[i][1] ); i++);\n",
    "ptr_map": {
      "queries": "queries_idx",
      "answers": "answers_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define M 2\n\nint main() {\n    size_t nqueries = N;\n    size_t next = 0;\n    size_t i = next;\n    int arr_answers[N][M];\n    int arr_queries[N][M];\n\n    __CPROVER_assume(next < nqueries);\n    for (size_t k = 0; k < nqueries; k++) {\n        __CPROVER_assume(k < N);\n        for (size_t j = 0; j < M; j++) {\n            __CPROVER_assume(j < M);\n        }\n    }\n\n    while (i < nqueries && (arr_answers[next][0] != arr_queries[i][0] || arr_answers[next][1] != arr_queries[i][1])) {\n        __CPROVER_assert(\n            i >= next && i < nqueries,\n            \"Loop invariant: index within bounds\"\n        );\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/res_msend.c",
    "line": 246,
    "column": 5,
    "source_code": "for (; next<nqueries && alens[next]; next++);\n",
    "abstract_code": "for (; next<nqueries && arr_alens[next]; next++);\n",
    "ptr_map": {
      "alens": "alens_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t nqueries = N;\n    size_t arr_alens[N];\n    size_t next = 0;\n\n    __CPROVER_assume(nqueries > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_alens[k] >= 0);\n    }\n\n    while (next < nqueries && arr_alens[next] != 0) {\n        __CPROVER_assert(\n            next >= 0 && next < nqueries,\n            \"Loop invariant: index within bounds\"\n        );\n        next++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/res_msend.c",
    "line": 314,
    "column": 2,
    "source_code": "for (i=0; i<nqueries; i++) if (alens[i]<0) alens[i] = 0;",
    "abstract_code": "for (i=0; i<nqueries; i++) if (arr_alens[i]<0) arr_alens[i] = 0;",
    "ptr_map": {
      "alens": "alens_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_alens[N];\n    size_t nqueries = N;\n    size_t i = 0;\n\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_alens[k] >= -100 && arr_alens[k] <= 100);\n    }\n\n    while (i < nqueries) {\n        __CPROVER_assert(i < N, \"Loop index within array bounds\");\n        __CPROVER_assert(\n            (arr_alens[i] >= 0) || (arr_alens[i] < 0 && i < N),\n            \"Array element is either non-negative or within bounds if negative\"\n        );\n\n        if (arr_alens[i] < 0) {\n            arr_alens[i] = 0;\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/lookup_name.c",
    "line": 174,
    "column": 2,
    "source_code": "for (i=0; i<nq; i++) {\n\t\tif (alens[i] < 4 || (abuf[i][3] & 15) == 2) return EAI_AGAIN;\n\t\tif ((abuf[i][3] & 15) == 3) return 0;\n\t\tif ((abuf[i][3] & 15) != 0) return EAI_FAIL;\n\t}\n",
    "abstract_code": "for (i=0; i<nq; i++) {\n\t\tif (arr_alens[i] < 4 || (arr_abuf[i][3] & 15) == 2) return EAI_AGAIN;\n\t\tif ((arr_abuf[i][3] & 15) == 3) return 0;\n\t\tif ((arr_abuf[i][3] & 15) != 0) return EAI_FAIL;\n\t}\n",
    "ptr_map": {
      "alens": "alens_idx",
      "abuf": "abuf_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define EAI_AGAIN 1\n#define EAI_FAIL 2\n\nint main() {\n    size_t nq = N;\n    size_t arr_alens[N];\n    unsigned char arr_abuf[N][4];\n    size_t i = 0;\n\n    __CPROVER_assume(nq <= N);\n    for (size_t k = 0; k < nq; k++) {\n        __CPROVER_assume(arr_alens[k] < 4 || (arr_abuf[k][3] & 15) != 0);\n    }\n\n    while (i < nq) {\n        __CPROVER_assert(\n            (arr_alens[i] >= 4) && ((arr_abuf[i][3] & 15) == 0),\n            \"Loop invariant violated\"\n        );\n\n        if (arr_alens[i] < 4 || (arr_abuf[i][3] & 15) == 2) return EAI_AGAIN;\n        if ((arr_abuf[i][3] & 15) == 3) return 0;\n        if ((arr_abuf[i][3] & 15) != 0) return EAI_FAIL;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/lookup_name.c",
    "line": 201,
    "column": 2,
    "source_code": "for (dots=l=0; name[l]; l++) if (name[l]=='.') dots++;",
    "abstract_code": "for (dots=l=0; arr_name[l]; l++) if (arr_name[l]=='.') dots++;",
    "ptr_map": {
      "name": "name_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_name[N];\n    int dots = 0;\n    int l = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_name[k] == 0 || arr_name[k] == '.');\n    }\n\n    while (l < N && arr_name[l] != 0) {\n        __CPROVER_assert(\n            dots >= 0 && dots <= l,\n            \"Loop invariant violated\"\n        );\n\n        if (arr_name[l] == '.') {\n            dots++;\n        }\n        l++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/inet_aton.c",
    "line": 34,
    "column": 2,
    "source_code": "for (i=0; i<4; i++) {\n\t\tif (a[i] > 255) return 0;\n\t\td[i] = a[i];\n\t}\n",
    "abstract_code": "for (i=0; i<4; i++) {\n\t\tif (arr_a[i] > 255) return 0;\n\t\tarr_d[i] = arr_a[i];\n\t}\n",
    "ptr_map": {
      "a": "a_idx",
      "d": "d_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 4\n\nint main() {\n    unsigned char arr_a[N];\n    unsigned char arr_d[N];\n    int i = 0;\n\n    for (int k = 0; k < N; k++) {\n        __CPROVER_assume(arr_a[k] >= 0 && arr_a[k] <= 255);\n    }\n\n    while (i < N) {\n        __CPROVER_assert(i >= 0 && i < N, \"Loop index within bounds\");\n        if (arr_a[i] > 255) return 0;\n        arr_d[i] = arr_a[i];\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/inet_pton.c",
    "line": 64,
    "column": 3,
    "source_code": "for (j=0; j<7-i; j++) ip[brk+j] = 0;",
    "abstract_code": "for (j=0; j<7-i; j++) arr_ip[brk+j] = 0;",
    "ptr_map": {
      "ip": "ip_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_ip[N];\n    int i, j, brk;\n\n    __CPROVER_assume(i >= 0 && i <= 7);\n    __CPROVER_assume(brk >= 0 && brk < N);\n    __CPROVER_assume(brk + (7 - i) <= N);\n\n    for (j = 0; j < 7 - i; j++) {\n        __CPROVER_assert(brk + j >= 0 && brk + j < N, \"Array bounds check\");\n        arr_ip[brk + j] = 0;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/network/inet_pton.c",
    "line": 66,
    "column": 2,
    "source_code": "for (j=0; j<8; j++) {\n\t\t*a++ = ip[j]>>8;\n\t\t*a++ = ip[j];\n\t}\n",
    "abstract_code": "for (j=0; j<8; j++) {\n\t\t*a++ = arr_ip[j]>>8;\n\t\t*a++ = arr_ip[j];\n\t}\n",
    "ptr_map": {
      "ip": "ip_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 8\n\nint main() {\n    unsigned short arr_ip[N];\n    unsigned short a[2 * N];\n    unsigned short *ptr = a;\n    int j;\n\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_ip[k] <= 0xFFFF);\n    }\n\n    for (j = 0; j < N; j++) {\n        __CPROVER_assert(ptr >= a && ptr < a + 2 * N, \"Write within bounds\");\n        *ptr = arr_ip[j] >> 8;\n        ptr++;\n\n        __CPROVER_assert(ptr >= a && ptr < a + 2 * N, \"Write within bounds\");\n        *ptr = arr_ip[j];\n        ptr++;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/conf/sysconf.c",
    "line": 208,
    "column": 4,
    "source_code": "for (; set[i]; set[i]&=set[i]-1, cnt++);\n",
    "abstract_code": "for (; arr_set[i]; arr_set[i]&=arr_set[i]-1, cnt++);\n",
    "ptr_map": {
      "set": "set_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    unsigned long arr_set[N];\n    size_t i = 0;\n    size_t cnt = 0;\n\n    __CPROVER_assume(i < N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_set[k] == 0 || (arr_set[k] & (arr_set[k] - 1)) == 0);\n    }\n\n    while (i < N && arr_set[i] != 0) {\n        __CPROVER_assert(\n            cnt == __CPROVER_popcount(arr_set[i]),\n            \"Loop invariant violated: cnt must equal popcount of current arr_set[i]\"\n        );\n\n        arr_set[i] &= arr_set[i] - 1;\n        cnt++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/math/__rem_pio2.c",
    "line": 179,
    "column": 2,
    "source_code": "while (tx[i] == 0.0)\n\t\ti--;",
    "abstract_code": "while (arr_tx[i] == 0.0)\n\t\ti--;",
    "ptr_map": {
      "tx": "tx_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    double arr_tx[N];\n    int i = N - 1;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_tx[k] >= 0.0 && arr_tx[k] <= 1.0);\n    }\n\n    while (i >= 0 && arr_tx[i] == 0.0) {\n        __CPROVER_assert(i >= 0 && i < N, \"Loop invariant: index within bounds\");\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/encrypt.c",
    "line": 16,
    "column": 3,
    "source_code": "for (j = 7; j >= 0; j--, key++)\n\t\t\tbkey[i] |= (uint32_t)(*key & 1) << j;",
    "abstract_code": "for (j = 7; j >= 0; j--, key++)\n\t\t\tarr_bkey[i] |= (uint32_t)(*key & 1) << j;",
    "ptr_map": {
      "bkey": "bkey_idx"
    },
    "invariant": "#include <stdint.h>\n#include <assert.h>\n\n#define N 100\n#define KEY_LEN 8\n\nint main() {\n    uint32_t arr_bkey[N];\n    uint8_t key[KEY_LEN];\n    int i = 0;\n    int j;\n    uint8_t *key_ptr;\n\n    __CPROVER_assume(i >= 0 && i < N);\n    for (int k = 0; k < KEY_LEN; k++) {\n        __CPROVER_assume(key[k] <= 1);\n    }\n\n    key_ptr = &key[0];\n    arr_bkey[i] = 0;\n    for (j = 7; j >= 0; j--, key_ptr++) {\n        __CPROVER_assert(j >= 0 && j < 8, \"j within bit shift range\");\n        __CPROVER_assert(key_ptr >= &key[0] && key_ptr < &key[KEY_LEN], \"key_ptr within bounds\");\n        \n        arr_bkey[i] |= (uint32_t)(*key_ptr & 1) << j;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/encrypt.c",
    "line": 33,
    "column": 3,
    "source_code": "for (j = 31; j >= 0; j--, p++)\n\t\t\tb[i] |= (uint32_t)(*p & 1) << j;",
    "abstract_code": "for (j = 31; j >= 0; j--, p++)\n\t\t\tarr_b[i] |= (uint32_t)(*p & 1) << j;",
    "ptr_map": {
      "b": "b_idx"
    },
    "invariant": "#include <stdint.h>\n#include <stddef.h>\n\n#define N 100\n#define B_SIZE 32\n\nint main() {\n    uint32_t arr_b[N];\n    uint8_t arr_p[N];\n    size_t i = 0;\n    int j;\n    uint8_t *p;\n\n    __CPROVER_assume(i < N);\n    p = &arr_p[0];\n    __CPROVER_assume(p >= &arr_p[0] && p <= &arr_p[N - 32]);\n\n    for (size_t k = 0; k < N; ++k) {\n        arr_b[k] = 0;\n        arr_p[k] = __CPROVER_nondet_uint8_t();\n    }\n\n    j = 31;\n    while (j >= 0) {\n        __CPROVER_assert(j >= 0 && j <= 31, \"Loop index j out of bounds\");\n        __CPROVER_assert(p >= &arr_p[0] && p < &arr_p[N], \"Pointer p out of bounds\");\n\n        arr_b[i] |= (uint32_t)(*p & 1) << j;\n\n        j--;\n        p++;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/encrypt.c",
    "line": 50,
    "column": 3,
    "source_code": "for (j = 31; j >= 0; j--)\n\t\t\t*p++ = b[i]>>j & 1;",
    "abstract_code": "for (j = 31; j >= 0; j--)\n\t\t\t*p++ = arr_b[i]>>j & 1;",
    "ptr_map": {
      "b": "b_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    unsigned int arr_b[N];\n    unsigned char p[N * 32];\n    unsigned int i = 0;\n    unsigned int j = 31;\n    unsigned int p_idx = 0;\n\n    __CPROVER_assume(i < N);\n\n    while (j >= 0 && j <= 31) {\n        __CPROVER_assert(p_idx < N * 32, \"Array bounds: p_idx within p array\");\n        __CPROVER_assert(i < N, \"Array bounds: i within arr_b array\");\n\n        p[p_idx] = (arr_b[i] >> j) & 1;\n        p_idx++;\n        j--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_blowfish.c",
    "line": 547,
    "column": 3,
    "source_code": "for (j = 0; j < 4; j++) {\n\t\t\ttmp[0] <<= 8;\n\t\t\ttmp[0] |= (unsigned char)*ptr; /* correct */\n\t\t\ttmp[1] <<= 8;\n\t\t\ttmp[1] |= (signed char)*ptr; /* bug */\n/*\n * Sign extension in the first char has no effect - nothing to overwrite yet,\n * and those extra 24 bits will be fully shifted out of the 32-bit word.  For\n * chars 2, 3, 4 in each four-char block, we set bit 7 of \"sign\" if sign\n * extension in tmp[1] occurs.  Once this flag is set, it remains set.\n */\n\t\t\tif (j)\n\t\t\t\tsign |= tmp[1] & 0x80;\n\t\t\tif (!*ptr)\n\t\t\t\tptr = key;\n\t\t\telse\n\t\t\t\tptr++;\n\t\t}\n",
    "abstract_code": "for (j = 0; j < 4; j++) {\n\t\t\tarr_tmp[0] <<= 8;\n\t\t\tarr_tmp[0] |= (unsigned char)*ptr; /* correct */\n\t\t\tarr_tmp[1] <<= 8;\n\t\t\tarr_tmp[1] |= (signed char)*ptr; /* bug */\n/*\n * Sign extension in the first char has no effect - nothing to overwrite yet,\n * and those extra 24 bits will be fully shifted out of the 32-bit word.  For\n * chars 2, 3, 4 in each four-char block, we set bit 7 of \"sign\" if sign\n * extension in arr_tmp[1] occurs.  Once this flag is set, it remains set.\n */\n\t\t\tif (j)\n\t\t\t\tsign |= arr_tmp[1] & 0x80;\n\t\t\tif (!*ptr)\n\t\t\t\tptr = key;\n\t\t\telse\n\t\t\t\tptr++;\n\t\t}\n",
    "ptr_map": {
      "tmp": "tmp_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    unsigned int arr_tmp[2] = {0, 0};\n    unsigned char sign = 0;\n    unsigned char key[N];\n    unsigned char *ptr = key;\n    int j;\n\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(key[k] < 256);\n    }\n\n    for (j = 0; j < 4; j++) {\n        __CPROVER_assert(\n            (sign == 0) ||\n            (j >= 1 && (arr_tmp[1] & 0x80) != 0),\n            \"Loop invariant violated\"\n        );\n\n        arr_tmp[0] <<= 8;\n        arr_tmp[0] |= (unsigned char)*ptr;\n        arr_tmp[1] <<= 8;\n        arr_tmp[1] |= (signed char)*ptr;\n\n        if (j) {\n            sign |= arr_tmp[1] & 0x80;\n        }\n\n        if (!*ptr) {\n            ptr = key;\n        } else {\n            ptr++;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_des.c",
    "line": 713,
    "column": 2,
    "source_code": "for (i = 0, ibit = 28; i < 4; i++, ibit -= 4) {\n\t\tunsigned int j = i << 1;\n\t\tk0 |= key_perm_maskl[i][(rawkey0 >> ibit) & 0xf] |\n\t\t      key_perm_maskl[i + 4][(rawkey1 >> ibit) & 0xf];\n\t\tk1 |= key_perm_maskr[j][(rawkey0 >> ibit) & 0xf];\n\t\tibit -= 4;\n\t\tk1 |= key_perm_maskr[j + 1][(rawkey0 >> ibit) & 0xf] |\n\t\t      key_perm_maskr[i + 8][(rawkey1 >> ibit) & 0xf];\n\t}\n",
    "abstract_code": "for (i = 0, ibit = 28; i < 4; i++, ibit -= 4) {\n\t\tunsigned int j = i << 1;\n\t\tk0 |= arr_key_perm_maskl[i][(rawkey0 >> ibit) & 0xf] |\n\t\t      arr_key_perm_maskl[i + 4][(rawkey1 >> ibit) & 0xf];\n\t\tk1 |= arr_key_perm_maskr[j][(rawkey0 >> ibit) & 0xf];\n\t\tibit -= 4;\n\t\tk1 |= arr_key_perm_maskr[j + 1][(rawkey0 >> ibit) & 0xf] |\n\t\t      arr_key_perm_maskr[i + 8][(rawkey1 >> ibit) & 0xf];\n\t}\n",
    "ptr_map": {
      "key_perm_maskl": "key_perm_maskl_idx",
      "key_perm_maskr": "key_perm_maskr_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n\n#define N 8\n#define M 16\n\nint main() {\n    unsigned int i, ibit, j;\n    uint32_t rawkey0, rawkey1;\n    uint32_t k0 = 0, k1 = 0;\n    uint32_t arr_key_perm_maskl[N][M];\n    uint32_t arr_key_perm_maskr[N * 2][M];\n\n    __CPROVER_assume(N >= 8);\n    for (unsigned int x = 0; x < N; x++) {\n        for (unsigned int y = 0; y < M; y++) {\n            __CPROVER_assume(arr_key_perm_maskl[x][y] < (1u << 31));\n            __CPROVER_assume(arr_key_perm_maskr[x][y] < (1u << 31));\n        }\n    }\n\n    for (i = 0, ibit = 28; i < 4; i++, ibit -= 4) {\n        __CPROVER_assert(i < N, \"arr_key_perm_maskl index i in bounds\");\n        __CPROVER_assert(i + 4 < N, \"arr_key_perm_maskl index i+4 in bounds\");\n        j = i << 1;\n        __CPROVER_assert(j < N * 2, \"arr_key_perm_maskr index j in bounds\");\n        __CPROVER_assert(j + 1 < N * 2, \"arr_key_perm_maskr index j+1 in bounds\");\n        __CPROVER_assert(i + 8 < N * 2, \"arr_key_perm_maskr index i+8 in bounds\");\n\n        __CPROVER_assert(((rawkey0 >> ibit) & 0xf) < M, \"column index rawkey0>>ibit in bounds\");\n        __CPROVER_assert(((rawkey1 >> ibit) & 0xf) < M, \"column index rawkey1>>ibit in bounds\");\n\n        k0 |= arr_key_perm_maskl[i][(rawkey0 >> ibit) & 0xf] |\n              arr_key_perm_maskl[i + 4][(rawkey1 >> ibit) & 0xf];\n        k1 |= arr_key_perm_maskr[j][(rawkey0 >> ibit) & 0xf];\n        ibit -= 4;\n        __CPROVER_assert(((rawkey0 >> ibit) & 0xf) < M, \"column index rawkey0>>(ibit-4) in bounds\");\n        __CPROVER_assert(((rawkey1 >> ibit) & 0xf) < M, \"column index rawkey1>>(ibit-4) in bounds\");\n        k1 |= arr_key_perm_maskr[j + 1][(rawkey0 >> ibit) & 0xf] |\n              arr_key_perm_maskr[i + 8][(rawkey1 >> ibit) & 0xf];\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_des.c",
    "line": 738,
    "column": 3,
    "source_code": "for (i = 0; i < 4; i++) {\n\t\t\tkl |= comp_maskl0[i][(t0 >> ibit) & 7];\n\t\t\tkr |= comp_maskr0[i][(t1 >> ibit) & 7];\n\t\t\tibit -= 4;\n\t\t\tkl |= comp_maskl1[i][(t0 >> ibit) & 0xf];\n\t\t\tkr |= comp_maskr1[i][(t1 >> ibit) & 0xf];\n\t\t\tibit -= 3;\n\t\t}\n",
    "abstract_code": "for (i = 0; i < 4; i++) {\n\t\t\tkl |= arr_comp_maskl0[i][(t0 >> ibit) & 7];\n\t\t\tkr |= arr_comp_maskr0[i][(t1 >> ibit) & 7];\n\t\t\tibit -= 4;\n\t\t\tkl |= arr_comp_maskl1[i][(t0 >> ibit) & 0xf];\n\t\t\tkr |= arr_comp_maskr1[i][(t1 >> ibit) & 0xf];\n\t\t\tibit -= 3;\n\t\t}\n",
    "ptr_map": {
      "comp_maskl0": "comp_maskl0_idx",
      "comp_maskl1": "comp_maskl1_idx",
      "comp_maskr1": "comp_maskr1_idx",
      "comp_maskr0": "comp_maskr0_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n\n#define N 4\n#define ARR_DIM 8\n\nint main() {\n    uint32_t arr_comp_maskl0[N][ARR_DIM];\n    uint32_t arr_comp_maskr0[N][ARR_DIM];\n    uint32_t arr_comp_maskl1[N][16];\n    uint32_t arr_comp_maskr1[N][16];\n    uint32_t kl = 0;\n    uint32_t kr = 0;\n    int32_t ibit;\n    uint32_t t0, t1;\n    int i = 0;\n\n    __CPROVER_assume(ibit >= 0 && ibit <= 31);\n    __CPROVER_assume(t0 >= 0 && t0 < (1U << 31));\n    __CPROVER_assume(t1 >= 0 && t1 < (1U << 31));\n\n    for (int a = 0; a < N; a++) {\n        for (int b = 0; b < ARR_DIM; b++) {\n            __CPROVER_assume(arr_comp_maskl0[a][b] < (1U << 31));\n            __CPROVER_assume(arr_comp_maskr0[a][b] < (1U << 31));\n        }\n        for (int b = 0; b < 16; b++) {\n            __CPROVER_assume(arr_comp_maskl1[a][b] < (1U << 31));\n            __CPROVER_assume(arr_comp_maskr1[a][b] < (1U << 31));\n        }\n    }\n\n    while (i < N) {\n        __CPROVER_assert(i >= 0 && i < N, \"Loop index within bounds for mask arrays\");\n        __CPROVER_assert((t0 >> ibit) & 7 < ARR_DIM, \"Index within bounds for arr_comp_maskl0\");\n        __CPROVER_assert((t1 >> ibit) & 7 < ARR_DIM, \"Index within bounds for arr_comp_maskr0\");\n        \n        kl |= arr_comp_maskl0[i][(t0 >> ibit) & 7];\n        kr |= arr_comp_maskr0[i][(t1 >> ibit) & 7];\n        ibit -= 4;\n        \n        __CPROVER_assert(ibit >= 0, \"ibit non-negative after first decrement\");\n        __CPROVER_assert((t0 >> ibit) & 0xf < 16, \"Index within bounds for arr_comp_maskl1\");\n        __CPROVER_assert((t1 >> ibit) & 0xf < 16, \"Index within bounds for arr_comp_maskr1\");\n        \n        kl |= arr_comp_maskl1[i][(t0 >> ibit) & 0xf];\n        kr |= arr_comp_maskr1[i][(t1 >> ibit) & 0xf];\n        ibit -= 3;\n        \n        __CPROVER_assert(ibit >= 0, \"ibit non-negative after second decrement\");\n        \n        i++;\n    }\n    \n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_des.c",
    "line": 766,
    "column": 3,
    "source_code": "for (i = 0, ibit = 28; i < 8; i++, ibit -= 4) {\n\t\t\tl |= ip_maskl[i][(l_in >> ibit) & 0xf] |\n\t\t\t     ip_maskl[i + 8][(r_in >> ibit) & 0xf];\n\t\t\tr |= ip_maskr[i][(l_in >> ibit) & 0xf] |\n\t\t\t     ip_maskr[i + 8][(r_in >> ibit) & 0xf];\n\t\t}\n",
    "abstract_code": "for (i = 0, ibit = 28; i < 8; i++, ibit -= 4) {\n\t\t\tl |= arr_ip_maskl[i][(l_in >> ibit) & 0xf] |\n\t\t\t     arr_ip_maskl[i + 8][(r_in >> ibit) & 0xf];\n\t\t\tr |= arr_ip_maskr[i][(l_in >> ibit) & 0xf] |\n\t\t\t     arr_ip_maskr[i + 8][(r_in >> ibit) & 0xf];\n\t\t}\n",
    "ptr_map": {
      "ip_maskr": "ip_maskr_idx",
      "ip_maskl": "ip_maskl_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n\n#define N 16\n#define M 16\n\nint main() {\n    uint32_t arr_ip_maskl[N][M];\n    uint32_t arr_ip_maskr[N][M];\n    uint32_t l = 0, r = 0;\n    uint32_t l_in, r_in;\n    int i, ibit;\n\n    __CPROVER_assume(l_in < (1U << 31));\n    __CPROVER_assume(r_in < (1U << 31));\n\n    for (i = 0, ibit = 28; i < 8; i++, ibit -= 4) {\n        __CPROVER_assert(i >= 0 && i < N - 8, \"ip_maskl[i] index in bounds\");\n        __CPROVER_assert(i + 8 >= 0 && i + 8 < N, \"ip_maskl[i+8] index in bounds\");\n        __CPROVER_assert(((l_in >> ibit) & 0xf) >= 0 && ((l_in >> ibit) & 0xf) < M, \"l_in shift index in bounds\");\n        __CPROVER_assert(((r_in >> ibit) & 0xf) >= 0 && ((r_in >> ibit) & 0xf) < M, \"r_in shift index in bounds\");\n\n        l |= arr_ip_maskl[i][(l_in >> ibit) & 0xf] |\n             arr_ip_maskl[i + 8][(r_in >> ibit) & 0xf];\n        r |= arr_ip_maskr[i][(l_in >> ibit) & 0xf] |\n             arr_ip_maskr[i + 8][(r_in >> ibit) & 0xf];\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/crypt/crypt_des.c",
    "line": 782,
    "column": 3,
    "source_code": "while (round--) {\n\t\t\tuint32_t r48l, r48r;\n\t\t\t/*\n\t\t\t * Expand R to 48 bits (simulate the E-box).\n\t\t\t */\n\t\t\tr48l\t= ((r & 0x00000001) << 23)\n\t\t\t\t| ((r & 0xf8000000) >> 9)\n\t\t\t\t| ((r & 0x1f800000) >> 11)\n\t\t\t\t| ((r & 0x01f80000) >> 13)\n\t\t\t\t| ((r & 0x001f8000) >> 15);\n\n\t\t\tr48r\t= ((r & 0x0001f800) << 7)\n\t\t\t\t| ((r & 0x00001f80) << 5)\n\t\t\t\t| ((r & 0x000001f8) << 3)\n\t\t\t\t| ((r & 0x0000001f) << 1)\n\t\t\t\t| ((r & 0x80000000) >> 31);\n\t\t\t/*\n\t\t\t * Do salting for crypt() and friends, and\n\t\t\t * XOR with the permuted key.\n\t\t\t */\n\t\t\tf = (r48l ^ r48r) & saltbits;\n\t\t\tr48l ^= f ^ *kl++;\n\t\t\tr48r ^= f ^ *kr++;\n\t\t\t/*\n\t\t\t * Do S-box lookups (which shrink it back to 32 bits)\n\t\t\t * and do the P-box permutation at the same time.\n\t\t\t */\n\t\t\tf = psbox[0][r48l >> 18]\n\t\t\t  | psbox[1][(r48l >> 12) & 0x3f]\n\t\t\t  | psbox[2][(r48l >> 6) & 0x3f]\n\t\t\t  | psbox[3][r48l & 0x3f]\n\t\t\t  | psbox[4][r48r >> 18]\n\t\t\t  | psbox[5][(r48r >> 12) & 0x3f]\n\t\t\t  | psbox[6][(r48r >> 6) & 0x3f]\n\t\t\t  | psbox[7][r48r & 0x3f];\n\t\t\t/*\n\t\t\t * Now that we've permuted things, complete f().\n\t\t\t */\n\t\t\tf ^= l;\n\t\t\tl = r;\n\t\t\tr = f;\n\t\t}\n",
    "abstract_code": "while (round--) {\n\t\t\tuint32_t r48l, r48r;\n\t\t\t/*\n\t\t\t * Expand R to 48 bits (simulate the E-box).\n\t\t\t */\n\t\t\tr48l\t= ((r & 0x00000001) << 23)\n\t\t\t\t| ((r & 0xf8000000) >> 9)\n\t\t\t\t| ((r & 0x1f800000) >> 11)\n\t\t\t\t| ((r & 0x01f80000) >> 13)\n\t\t\t\t| ((r & 0x001f8000) >> 15);\n\n\t\t\tr48r\t= ((r & 0x0001f800) << 7)\n\t\t\t\t| ((r & 0x00001f80) << 5)\n\t\t\t\t| ((r & 0x000001f8) << 3)\n\t\t\t\t| ((r & 0x0000001f) << 1)\n\t\t\t\t| ((r & 0x80000000) >> 31);\n\t\t\t/*\n\t\t\t * Do salting for crypt() and friends, and\n\t\t\t * XOR with the permuted key.\n\t\t\t */\n\t\t\tf = (r48l ^ r48r) & saltbits;\n\t\t\tr48l ^= f ^ *kl++;\n\t\t\tr48r ^= f ^ *kr++;\n\t\t\t/*\n\t\t\t * Do S-box lookups (which shrink it back to 32 bits)\n\t\t\t * and do the P-box permutation at the same time.\n\t\t\t */\n\t\t\tf = arr_psbox[0][r48l >> 18]\n\t\t\t  | arr_psbox[1][(r48l >> 12) & 0x3f]\n\t\t\t  | arr_psbox[2][(r48l >> 6) & 0x3f]\n\t\t\t  | arr_psbox[3][r48l & 0x3f]\n\t\t\t  | arr_psbox[4][r48r >> 18]\n\t\t\t  | arr_psbox[5][(r48r >> 12) & 0x3f]\n\t\t\t  | arr_psbox[6][(r48r >> 6) & 0x3f]\n\t\t\t  | arr_psbox[7][r48r & 0x3f];\n\t\t\t/*\n\t\t\t * Now that we've permuted things, complete f().\n\t\t\t */\n\t\t\tf ^= l;\n\t\t\tl = r;\n\t\t\tr = f;\n\t\t}\n",
    "ptr_map": {
      "psbox": "psbox_idx"
    },
    "invariant": "#include <stdint.h>\n#include <stddef.h>\n\n#define ROUNDS 16\n#define PSBOX_ROWS 8\n#define PSBOX_COLS 64\n\nint main() {\n    uint32_t round = ROUNDS;\n    uint32_t l = __CPROVER_nondet_uint32();\n    uint32_t r = __CPROVER_nondet_uint32();\n    uint32_t f;\n    uint32_t saltbits = __CPROVER_nondet_uint32();\n    uint32_t *kl = __CPROVER_nondet_pointer();\n    uint32_t *kr = __CPROVER_nondet_pointer();\n    uint32_t arr_psbox[PSBOX_ROWS][PSBOX_COLS];\n    \n    __CPROVER_assume(kl != NULL && kr != NULL);\n    for (size_t i = 0; i < PSBOX_ROWS; i++) {\n        for (size_t j = 0; j < PSBOX_COLS; j++) {\n            arr_psbox[i][j] = __CPROVER_nondet_uint32();\n        }\n    }\n\n    uint32_t initial_round = round;\n    uint32_t initial_l = l;\n    uint32_t initial_r = r;\n\n    while (round--) {\n        uint32_t r48l, r48r;\n        \n        __CPROVER_assert(round < initial_round, \"round decreases\");\n        __CPROVER_assert(round + 1 == initial_round - (initial_round - round - 1), \"round decrement invariant\");\n\n        r48l = ((r & 0x00000001) << 23)\n            | ((r & 0xf8000000) >> 9)\n            | ((r & 0x1f800000) >> 11)\n            | ((r & 0x01f80000) >> 13)\n            | ((r & 0x001f8000) >> 15);\n\n        r48r = ((r & 0x0001f800) << 7)\n            | ((r & 0x00001f80) << 5)\n            | ((r & 0x000001f8) << 3)\n            | ((r & 0x0000001f) << 1)\n            | ((r & 0x80000000) >> 31);\n\n        f = (r48l ^ r48r) & saltbits;\n        r48l ^= f ^ *kl++;\n        r48r ^= f ^ *kr++;\n\n        f = arr_psbox[0][r48l >> 18]\n          | arr_psbox[1][(r48l >> 12) & 0x3f]\n          | arr_psbox[2][(r48l >> 6) & 0x3f]\n          | arr_psbox[3][r48l & 0x3f]\n          | arr_psbox[4][r48r >> 18]\n          | arr_psbox[5][(r48r >> 12) & 0x3f]\n          | arr_psbox[6][(r48r >> 6) & 0x3f]\n          | arr_psbox[7][r48r & 0x3f];\n\n        f ^= l;\n        l = r;\n        r = f;\n    }\n    \n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_des.c",
    "line": 835,
    "column": 3,
    "source_code": "for (i = 0, ibit = 28; i < 4; i++, ibit -= 4) {\n\t\t\tro |= fp_maskr[i][(l >> ibit) & 0xf] |\n\t\t\t      fp_maskr[i + 4][(r >> ibit) & 0xf];\n\t\t\tibit -= 4;\n\t\t\tlo |= fp_maskl[i][(l >> ibit) & 0xf] |\n\t\t\t      fp_maskl[i + 4][(r >> ibit) & 0xf];\n\t\t}\n",
    "abstract_code": "for (i = 0, ibit = 28; i < 4; i++, ibit -= 4) {\n\t\t\tro |= arr_fp_maskr[i][(l >> ibit) & 0xf] |\n\t\t\t      arr_fp_maskr[i + 4][(r >> ibit) & 0xf];\n\t\t\tibit -= 4;\n\t\t\tlo |= arr_fp_maskl[i][(l >> ibit) & 0xf] |\n\t\t\t      arr_fp_maskl[i + 4][(r >> ibit) & 0xf];\n\t\t}\n",
    "ptr_map": {
      "fp_maskr": "fp_maskr_idx",
      "fp_maskl": "fp_maskl_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n\n#define N 8\n#define M 16\n\nint main() {\n    uint32_t arr_fp_maskr[N][M];\n    uint32_t arr_fp_maskl[N][M];\n    uint32_t ro = 0;\n    uint32_t lo = 0;\n    uint32_t l, r;\n    int i, ibit;\n\n    __CPROVER_assume(l < (1U << 32));\n    __CPROVER_assume(r < (1U << 32));\n\n    for (i = 0, ibit = 28; i < 4; i++, ibit -= 4) {\n        __CPROVER_assert(i >= 0 && i < 4, \"i within bounds\");\n        __CPROVER_assert(i + 4 < N, \"fp_maskr index i+4 within bounds\");\n        __CPROVER_assert(((l >> ibit) & 0xf) < M, \"l shift index within bounds\");\n        __CPROVER_assert(((r >> ibit) & 0xf) < M, \"r shift index within bounds\");\n\n        ro |= arr_fp_maskr[i][(l >> ibit) & 0xf] |\n              arr_fp_maskr[i + 4][(r >> ibit) & 0xf];\n        ibit -= 4;\n\n        __CPROVER_assert(i < 4, \"i within bounds for fp_maskl\");\n        __CPROVER_assert(i + 4 < N, \"fp_maskl index i+4 within bounds\");\n        __CPROVER_assert(((l >> ibit) & 0xf) < M, \"l shift index within bounds (second)\");\n        __CPROVER_assert(((r >> ibit) & 0xf) < M, \"r shift index within bounds (second)\");\n\n        lo |= arr_fp_maskl[i][(l >> ibit) & 0xf] |\n              arr_fp_maskl[i + 4][(r >> ibit) & 0xf];\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_sha256.c",
    "line": 48,
    "column": 2,
    "source_code": "for (i = 0; i < 16; i++) {\n\t\tW[i] = (uint32_t)buf[4*i]<<24;\n\t\tW[i] |= (uint32_t)buf[4*i+1]<<16;\n\t\tW[i] |= (uint32_t)buf[4*i+2]<<8;\n\t\tW[i] |= buf[4*i+3];\n\t}\n",
    "abstract_code": "for (i = 0; i < 16; i++) {\n\t\tarr_W[i] = (uint32_t)arr_buf[4*i]<<24;\n\t\tarr_W[i] |= (uint32_t)arr_buf[4*i+1]<<16;\n\t\tarr_W[i] |= (uint32_t)arr_buf[4*i+2]<<8;\n\t\tarr_W[i] |= arr_buf[4*i+3];\n\t}\n",
    "ptr_map": {
      "buf": "buf_idx",
      "W": "W_idx"
    },
    "invariant": "#include <stdint.h>\n#include <stddef.h>\n\n#define N 16\n#define BUF_SIZE 64\n\nint main() {\n    uint32_t arr_W[N];\n    uint8_t arr_buf[BUF_SIZE];\n    size_t i = 0;\n\n    __CPROVER_assume(BUF_SIZE >= 4 * N);\n\n    while (i < N) {\n        __CPROVER_assert(i < N, \"Loop index within arr_W bounds\");\n        __CPROVER_assert(4 * i + 3 < BUF_SIZE, \"Buffer access within bounds\");\n\n        arr_W[i] = (uint32_t)arr_buf[4 * i] << 24;\n        arr_W[i] |= (uint32_t)arr_buf[4 * i + 1] << 16;\n        arr_W[i] |= (uint32_t)arr_buf[4 * i + 2] << 8;\n        arr_W[i] |= arr_buf[4 * i + 3];\n\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/crypt/crypt_sha256.c",
    "line": 161,
    "column": 2,
    "source_code": "while (--n >= 0) {\n\t\t*s++ = b64[u % 64];\n\t\tu /= 64;\n\t}\n",
    "abstract_code": "while (--n >= 0) {\n\t\t*s++ = arr_b64[u % 64];\n\t\tu /= 64;\n\t}\n",
    "ptr_map": {
      "b64": "b64_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_b64[64];\n    char s[N];\n    char *ptr = s;\n    unsigned int u;\n    int n;\n\n    __CPROVER_assume(n >= 0 && n <= N);\n    __CPROVER_assume(ptr >= s && ptr + n <= s + N);\n\n    while (--n >= 0) {\n        __CPROVER_assert(ptr >= s && ptr < s + N, \"Write within bounds\");\n        __CPROVER_assert(u % 64 >= 0 && u % 64 < 64, \"Read within bounds\");\n\n        *ptr++ = arr_b64[u % 64];\n        u /= 64;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_sha256.c",
    "line": 240,
    "column": 2,
    "source_code": "for (i = 0; i < SALT_MAX && salt[i] && salt[i] != '$'; i++)\n\t\t/* reject characters that interfere with /etc/shadow parsing */\n\t\tif (salt[i] == '\\n' || salt[i] == ':')\n\t\t\treturn 0;",
    "abstract_code": "for (i = 0; i < SALT_MAX && arr_salt[i] && arr_salt[i] != '$'; i++)\n\t\t/* reject characters that interfere with /etc/shadow parsing */\n\t\tif (arr_salt[i] == '\\n' || arr_salt[i] == ':')\n\t\t\treturn 0;",
    "ptr_map": {
      "salt": "salt_idx"
    },
    "invariant": "#include <stddef.h>\n#define SALT_MAX 100\n\nint main() {\n    char arr_salt[SALT_MAX];\n    int i = 0;\n    int result = 1;\n\n    __CPROVER_assume(SALT_MAX > 0);\n    for (size_t k = 0; k < SALT_MAX; k++) {\n        __CPROVER_assume(arr_salt[k] >= 0 && arr_salt[k] <= 127);\n    }\n\n    while (i < SALT_MAX && arr_salt[i] && arr_salt[i] != '$') {\n        __CPROVER_assert(\n            result == 1,\n            \"Loop invariant violated\"\n        );\n\n        if (arr_salt[i] == '\\n' || arr_salt[i] == ':') {\n            result = 0;\n            break;\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_md5.c",
    "line": 45,
    "column": 2,
    "source_code": "for (i = 0; i < 16; i++) {\n\t\tW[i] = buf[4*i];\n\t\tW[i] |= (uint32_t)buf[4*i+1]<<8;\n\t\tW[i] |= (uint32_t)buf[4*i+2]<<16;\n\t\tW[i] |= (uint32_t)buf[4*i+3]<<24;\n\t}\n",
    "abstract_code": "for (i = 0; i < 16; i++) {\n\t\tarr_W[i] = arr_buf[4*i];\n\t\tarr_W[i] |= (uint32_t)arr_buf[4*i+1]<<8;\n\t\tarr_W[i] |= (uint32_t)arr_buf[4*i+2]<<16;\n\t\tarr_W[i] |= (uint32_t)arr_buf[4*i+3]<<24;\n\t}\n",
    "ptr_map": {
      "buf": "buf_idx",
      "W": "W_idx"
    },
    "invariant": "#include <stdint.h>\n#include <assert.h>\n\n#define N 16\n#define BUF_SIZE (4*N)\n\nint main() {\n    uint8_t arr_buf[BUF_SIZE];\n    uint32_t arr_W[N];\n    int i;\n\n    __CPROVER_assume(BUF_SIZE > 0);\n\n    for (i = 0; i < N; i++) {\n        __CPROVER_assert(i >= 0 && i < N, \"arr_W index bounds\");\n        __CPROVER_assert(4*i >= 0 && 4*i < BUF_SIZE, \"arr_buf index 4*i bounds\");\n        __CPROVER_assert(4*i+1 >= 0 && 4*i+1 < BUF_SIZE, \"arr_buf index 4*i+1 bounds\");\n        __CPROVER_assert(4*i+2 >= 0 && 4*i+2 < BUF_SIZE, \"arr_buf index 4*i+2 bounds\");\n        __CPROVER_assert(4*i+3 >= 0 && 4*i+3 < BUF_SIZE, \"arr_buf index 4*i+3 bounds\");\n\n        arr_W[i] = arr_buf[4*i];\n        arr_W[i] |= (uint32_t)arr_buf[4*i+1]<<8;\n        arr_W[i] |= (uint32_t)arr_buf[4*i+2]<<16;\n        arr_W[i] |= (uint32_t)arr_buf[4*i+3]<<24;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/crypt/crypt_md5.c",
    "line": 190,
    "column": 2,
    "source_code": "while (--n >= 0) {\n\t\t*s++ = b64[u % 64];\n\t\tu /= 64;\n\t}\n",
    "abstract_code": "while (--n >= 0) {\n\t\t*s++ = arr_b64[u % 64];\n\t\tu /= 64;\n\t}\n",
    "ptr_map": {
      "b64": "b64_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define B64_SIZE 64\n\nint main() {\n    char arr_b64[B64_SIZE];\n    char s[N];\n    char *ptr = s;\n    unsigned int u;\n    int n = N;\n\n    __CPROVER_assume(u < (1U << 31));\n    __CPROVER_assume(n > 0 && n <= N);\n    for (size_t k = 0; k < B64_SIZE; k++) {\n        __CPROVER_assume(arr_b64[k] >= 0);\n    }\n\n    while (--n >= 0) {\n        __CPROVER_assert(ptr >= s && ptr < s + N, \"Pointer within bounds\");\n        __CPROVER_assert(u % 64 < B64_SIZE, \"Index within b64 array bounds\");\n        \n        *ptr++ = arr_b64[u % 64];\n        u /= 64;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_md5.c",
    "line": 214,
    "column": 2,
    "source_code": "for (i = 0; i < SALT_MAX && salt[i] && salt[i] != '$'; i++);\n",
    "abstract_code": "for (i = 0; i < SALT_MAX && arr_salt[i] && arr_salt[i] != '$'; i++);\n",
    "ptr_map": {
      "salt": "salt_idx"
    },
    "invariant": "#include <stddef.h>\n#define SALT_MAX 100\n\nint main() {\n    char arr_salt[SALT_MAX];\n    size_t i = 0;\n\n    for (size_t k = 0; k < SALT_MAX; k++) {\n        __CPROVER_assume(arr_salt[k] >= 0 && arr_salt[k] <= 127);\n    }\n\n    while (i < SALT_MAX && arr_salt[i] != 0 && arr_salt[i] != '$') {\n        __CPROVER_assert(\n            i < SALT_MAX,\n            \"Loop invariant: index within bounds\"\n        );\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_sha512.c",
    "line": 61,
    "column": 2,
    "source_code": "for (i = 0; i < 16; i++) {\n\t\tW[i] = (uint64_t)buf[8*i]<<56;\n\t\tW[i] |= (uint64_t)buf[8*i+1]<<48;\n\t\tW[i] |= (uint64_t)buf[8*i+2]<<40;\n\t\tW[i] |= (uint64_t)buf[8*i+3]<<32;\n\t\tW[i] |= (uint64_t)buf[8*i+4]<<24;\n\t\tW[i] |= (uint64_t)buf[8*i+5]<<16;\n\t\tW[i] |= (uint64_t)buf[8*i+6]<<8;\n\t\tW[i] |= buf[8*i+7];\n\t}\n",
    "abstract_code": "for (i = 0; i < 16; i++) {\n\t\tarr_W[i] = (uint64_t)arr_buf[8*i]<<56;\n\t\tarr_W[i] |= (uint64_t)arr_buf[8*i+1]<<48;\n\t\tarr_W[i] |= (uint64_t)arr_buf[8*i+2]<<40;\n\t\tarr_W[i] |= (uint64_t)arr_buf[8*i+3]<<32;\n\t\tarr_W[i] |= (uint64_t)arr_buf[8*i+4]<<24;\n\t\tarr_W[i] |= (uint64_t)arr_buf[8*i+5]<<16;\n\t\tarr_W[i] |= (uint64_t)arr_buf[8*i+6]<<8;\n\t\tarr_W[i] |= arr_buf[8*i+7];\n\t}\n",
    "ptr_map": {
      "buf": "buf_idx",
      "W": "W_idx"
    },
    "invariant": "#include <stdint.h>\n#include <stddef.h>\n\n#define N 16\n#define BUF_SIZE 128\n\nint main() {\n    uint8_t arr_buf[BUF_SIZE];\n    uint64_t arr_W[N];\n    size_t i;\n\n    __CPROVER_assume(BUF_SIZE >= 8 * N);\n\n    for (i = 0; i < N; i++) {\n        __CPROVER_assert(i < N, \"arr_W index bounds\");\n        __CPROVER_assert(8 * i + 7 < BUF_SIZE, \"arr_buf index bounds\");\n        \n        arr_W[i] = (uint64_t)arr_buf[8*i] << 56;\n        arr_W[i] |= (uint64_t)arr_buf[8*i+1] << 48;\n        arr_W[i] |= (uint64_t)arr_buf[8*i+2] << 40;\n        arr_W[i] |= (uint64_t)arr_buf[8*i+3] << 32;\n        arr_W[i] |= (uint64_t)arr_buf[8*i+4] << 24;\n        arr_W[i] |= (uint64_t)arr_buf[8*i+5] << 16;\n        arr_W[i] |= (uint64_t)arr_buf[8*i+6] << 8;\n        arr_W[i] |= arr_buf[8*i+7];\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/crypt/crypt_sha512.c",
    "line": 182,
    "column": 2,
    "source_code": "while (--n >= 0) {\n\t\t*s++ = b64[u % 64];\n\t\tu /= 64;\n\t}\n",
    "abstract_code": "while (--n >= 0) {\n\t\t*s++ = arr_b64[u % 64];\n\t\tu /= 64;\n\t}\n",
    "ptr_map": {
      "b64": "b64_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_b64[64];\n    char s[N];\n    char *ptr = s;\n    unsigned int u;\n    int n;\n\n    __CPROVER_assume(n > 0 && n <= N);\n    __CPROVER_assume(u >= 0);\n\n    while (--n >= 0) {\n        __CPROVER_assert(ptr >= s && ptr < s + N, \"Write within bounds\");\n        __CPROVER_assert(u % 64 >= 0 && u % 64 < 64, \"Index within arr_b64 bounds\");\n\n        *ptr++ = arr_b64[u % 64];\n        u /= 64;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_sha512.c",
    "line": 218,
    "column": 2,
    "source_code": "for (i = 0; i <= KEY_MAX && key[i]; i++);\n",
    "abstract_code": "for (i = 0; i <= KEY_MAX && arr_key[i]; i++);\n",
    "ptr_map": {
      "key": "key_idx"
    },
    "invariant": "#include <stddef.h>\n#define KEY_MAX 100\n\nint main() {\n    size_t arr_key[KEY_MAX + 1];\n    size_t i = 0;\n\n    for (size_t k = 0; k <= KEY_MAX; k++) {\n        __CPROVER_assume(arr_key[k] == 0 || arr_key[k] > 0);\n    }\n\n    while (i <= KEY_MAX && arr_key[i] != 0) {\n        __CPROVER_assert(i <= KEY_MAX, \"Loop index within KEY_MAX\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/crypt/crypt_sha512.c",
    "line": 262,
    "column": 2,
    "source_code": "for (i = 0; i < SALT_MAX && salt[i] && salt[i] != '$'; i++)\n\t\t/* reject characters that interfere with /etc/shadow parsing */\n\t\tif (salt[i] == '\\n' || salt[i] == ':')\n\t\t\treturn 0;",
    "abstract_code": "for (i = 0; i < SALT_MAX && arr_salt[i] && arr_salt[i] != '$'; i++)\n\t\t/* reject characters that interfere with /etc/shadow parsing */\n\t\tif (arr_salt[i] == '\\n' || arr_salt[i] == ':')\n\t\t\treturn 0;",
    "ptr_map": {
      "salt": "salt_idx"
    },
    "invariant": "#include <stddef.h>\n#define SALT_MAX 100\n\nint main() {\n    char arr_salt[SALT_MAX];\n    size_t i = 0;\n    int result = 1;\n\n    for (size_t k = 0; k < SALT_MAX; k++) {\n        __CPROVER_assume(arr_salt[k] >= 0 && arr_salt[k] <= 127);\n    }\n\n    while (i < SALT_MAX && arr_salt[i] && arr_salt[i] != '$') {\n        __CPROVER_assert(\n            result == 1,\n            \"Loop invariant violated: result must remain 1 before any rejection\"\n        );\n\n        if (arr_salt[i] == '\\n' || arr_salt[i] == ':') {\n            result = 0;\n            break;\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/signal/sigandset.c",
    "line": 9,
    "column": 2,
    "source_code": "for(; i < SST_SIZE; i++) d[i] = l[i] & r[i];",
    "abstract_code": "for(; i < SST_SIZE; i++) arr_d[i] = arr_l[i] & arr_r[i];",
    "ptr_map": {
      "d": "d_idx",
      "r": "r_idx",
      "l": "l_idx"
    },
    "invariant": "#include <stddef.h>\n#define SST_SIZE 32\n\nint main() {\n    unsigned long arr_d[SST_SIZE];\n    unsigned long arr_l[SST_SIZE];\n    unsigned long arr_r[SST_SIZE];\n    size_t i = 0;\n\n    __CPROVER_assume(SST_SIZE > 0);\n\n    while (i < SST_SIZE) {\n        __CPROVER_assert(i < SST_SIZE, \"Loop index within bounds\");\n        arr_d[i] = arr_l[i] & arr_r[i];\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/signal/sigorset.c",
    "line": 9,
    "column": 2,
    "source_code": "for(; i < SST_SIZE; i++) d[i] = l[i] | r[i];",
    "abstract_code": "for(; i < SST_SIZE; i++) arr_d[i] = arr_l[i] | arr_r[i];",
    "ptr_map": {
      "d": "d_idx",
      "r": "r_idx",
      "l": "l_idx"
    },
    "invariant": "#include <stddef.h>\n#define SST_SIZE 100\n\nint main() {\n    unsigned int arr_d[SST_SIZE];\n    unsigned int arr_l[SST_SIZE];\n    unsigned int arr_r[SST_SIZE];\n    size_t i = 0;\n\n    while (i < SST_SIZE) {\n        __CPROVER_assert(i < SST_SIZE, \"Loop index within bounds\");\n        arr_d[i] = arr_l[i] | arr_r[i];\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/memmove.c",
    "line": 31,
    "column": 4,
    "source_code": "while ((uintptr_t)(d+n) % WS) {\n\t\t\t\tif (!n--) return dest;\n\t\t\t\td[n] = s[n];\n\t\t\t}\n",
    "abstract_code": "while ((uintptr_t)(d+n) % WS) {\n\t\t\t\tif (!n--) return dest;\n\t\t\t\tarr_d[n] = arr_s[n];\n\t\t\t}\n",
    "ptr_map": {
      "d": "d_idx",
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n\n#define WS 8\n#define N 100\n\nint main() {\n    unsigned char arr_d[N];\n    unsigned char arr_s[N];\n    size_t n = N;\n    size_t d_idx = 0;\n    size_t s_idx = 0;\n\n    __CPROVER_assume(n > 0 && n <= N);\n    __CPROVER_assume(((uintptr_t)(d_idx + n) % WS) != 0);\n\n    while (((uintptr_t)(d_idx + n) % WS) != 0) {\n        __CPROVER_assert(n > 0 && n <= N, \"Loop invariant: n within bounds\");\n\n        if (n == 0) {\n            return 0;\n        }\n        n--;\n        arr_d[n] = arr_s[n];\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/memmove.c",
    "line": 38,
    "column": 3,
    "source_code": "while (n) n--, d[n] = s[n];",
    "abstract_code": "while (n) n--, arr_d[n] = arr_s[n];",
    "ptr_map": {
      "d": "d_idx",
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    unsigned char arr_s[N];\n    unsigned char arr_d[N];\n    size_t n = N;\n\n    __CPROVER_assume(n <= N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] >= 0);\n    }\n\n    while (n) {\n        __CPROVER_assert(n > 0 && n <= N, \"Loop index bounds\");\n        n--;\n        arr_d[n] = arr_s[n];\n        __CPROVER_assert(n < N, \"Array write bounds\");\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/memrchr.c",
    "line": 7,
    "column": 2,
    "source_code": "while (n--) if (s[n]==c) return (void *)(s+n);",
    "abstract_code": "while (n--) if (arr_s[n]==c) return (void *)(s+n);",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    unsigned char arr_s[N];\n    unsigned char c;\n    size_t n = N;\n    size_t s_idx = 0;\n    size_t result = 0;\n    int found = 0;\n\n    __CPROVER_assume(n > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] >= 0);\n    }\n\n    while (n--) {\n        __CPROVER_assert(\n            (found == 0) ||\n            (found == 1 && arr_s[n] == c && result == s_idx + n),\n            \"Loop invariant violated\"\n        );\n\n        if (arr_s[n] == c) {\n            found = 1;\n            result = s_idx + n;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/strstr.c",
    "line": 41,
    "column": 2,
    "source_code": "for (l=0; n[l] && h[l]; l++)\n\t\tBITOP(byteset, n[l], |=), shift[n[l]] = l+1;",
    "abstract_code": "for (l=0; arr_n[l] && arr_h[l]; l++)\n\t\tBITOP(byteset, arr_n[l], |=), arr_shift[arr_n[l]] = l+1;",
    "ptr_map": {
      "h": "h_idx",
      "n": "n_idx",
      "shift": "shift_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define CHAR_SET_SIZE 256\n\nint main() {\n    unsigned char arr_n[N];\n    unsigned char arr_h[N];\n    unsigned long byteset = 0;\n    size_t arr_shift[CHAR_SET_SIZE];\n    size_t l = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_n[k] != 0 && arr_h[k] != 0);\n    }\n    for (size_t k = 0; k < CHAR_SET_SIZE; k++) {\n        arr_shift[k] = 0;\n    }\n\n    while (l < N && arr_n[l] != 0 && arr_h[l] != 0) {\n        __CPROVER_assert(\n            (byteset == 0) ||\n            (l > 0 && (byteset & (1UL << arr_n[l-1])) != 0 && arr_shift[arr_n[l-1]] == l),\n            \"Loop invariant violated\"\n        );\n\n        byteset |= (1UL << arr_n[l]);\n        arr_shift[arr_n[l]] = l + 1;\n        l++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/strstr.c",
    "line": 47,
    "column": 2,
    "source_code": "while (jp+k<l) {\n\t\tif (n[ip+k] == n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (n[ip+k] > n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "abstract_code": "while (jp+k<l) {\n\t\tif (arr_n[ip+k] == arr_n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (arr_n[ip+k] > arr_n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "ptr_map": {
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define L 50\n\nint main() {\n    unsigned char arr_n[N];\n    size_t ip = 0, jp = 0, k = 1, p = 1;\n    size_t l = L;\n\n    __CPROVER_assume(l > 0 && l < N);\n    __CPROVER_assume(ip < l && jp < l && ip <= jp);\n    __CPROVER_assume(k >= 1 && p >= 1);\n    __CPROVER_assume(jp + k <= l);\n\n    for (size_t idx = 0; idx < N; idx++) {\n        __CPROVER_assume(arr_n[idx] >= 0);\n    }\n\n    while (jp + k < l) {\n        __CPROVER_assert(\n            ip <= jp && jp < l && k >= 1 && p >= 1 && ip + k < N && jp + k < N,\n            \"Loop invariant: array bounds and variable relationships\"\n        );\n\n        if (arr_n[ip + k] == arr_n[jp + k]) {\n            if (k == p) {\n                jp += p;\n                k = 1;\n            } else {\n                k++;\n            }\n        } else if (arr_n[ip + k] > arr_n[jp + k]) {\n            jp += k;\n            k = 1;\n            p = jp - ip;\n        } else {\n            ip = jp++;\n            k = p = 1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/strstr.c",
    "line": 67,
    "column": 2,
    "source_code": "while (jp+k<l) {\n\t\tif (n[ip+k] == n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (n[ip+k] < n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "abstract_code": "while (jp+k<l) {\n\t\tif (arr_n[ip+k] == arr_n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (arr_n[ip+k] < arr_n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "ptr_map": {
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define L 50\n\nint main() {\n    unsigned char arr_n[N];\n    size_t ip = 0, jp = 0, k = 1, p = 1;\n    size_t l = L;\n\n    __CPROVER_assume(l < N);\n    __CPROVER_assume(ip < l && jp < l);\n    __CPROVER_assume(k >= 1 && p >= 1);\n    __CPROVER_assume(jp + k <= l);\n\n    while (jp + k < l) {\n        __CPROVER_assert(\n            ip < l && jp < l && k >= 1 && p >= 1,\n            \"Loop invariant: indices in bounds and positive\"\n        );\n        __CPROVER_assert(\n            ip <= jp,\n            \"Loop invariant: ip never exceeds jp\"\n        );\n        __CPROVER_assert(\n            p == jp - ip || p == 1,\n            \"Loop invariant: p equals jp-ip or is 1\"\n        );\n\n        if (arr_n[ip + k] == arr_n[jp + k]) {\n            if (k == p) {\n                jp += p;\n                k = 1;\n            } else k++;\n        } else if (arr_n[ip + k] < arr_n[jp + k]) {\n            jp += k;\n            k = 1;\n            p = jp - ip;\n        } else {\n            ip = jp++;\n            k = p = 1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/strstr.c",
    "line": 124,
    "column": 3,
    "source_code": "for (k=MAX(ms+1,mem); n[k] && n[k] == h[k]; k++);\n",
    "abstract_code": "for (k=MAX(ms+1,mem); arr_n[k] && arr_n[k] == arr_h[k]; k++);\n",
    "ptr_map": {
      "h": "h_idx",
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_n[N];\n    size_t arr_h[N];\n    size_t ms, mem, k;\n\n    __CPROVER_assume(N > 0);\n    for (size_t idx = 0; idx < N; idx++) {\n        __CPROVER_assume(arr_n[idx] == 0 || (arr_n[idx] == arr_h[idx]));\n    }\n\n    size_t start = (ms + 1) > mem ? (ms + 1) : mem;\n    __CPROVER_assume(start < N);\n\n    k = start;\n    while (k < N && arr_n[k] != 0 && arr_n[k] == arr_h[k]) {\n        __CPROVER_assert(\n            k >= start && k < N,\n            \"Loop invariant: index within bounds\"\n        );\n        k++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/strstr.c",
    "line": 131,
    "column": 3,
    "source_code": "for (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);\n",
    "abstract_code": "for (k=ms+1; k>mem && arr_n[k-1] == arr_h[k-1]; k--);\n",
    "ptr_map": {
      "h": "h_idx",
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_n[N];\n    size_t arr_h[N];\n    size_t ms, mem, k;\n\n    __CPROVER_assume(N > 0);\n    __CPROVER_assume(ms < N - 1);\n    __CPROVER_assume(mem < N);\n    __CPROVER_assume(ms >= mem);\n\n    for (size_t i = 0; i < N; i++) {\n        __CPROVER_assume(arr_n[i] < 256);\n        __CPROVER_assume(arr_h[i] < 256);\n    }\n\n    k = ms + 1;\n    while (k > mem && arr_n[k - 1] == arr_h[k - 1]) {\n        __CPROVER_assert(k - 1 < N, \"Array index k-1 out of bounds\");\n        __CPROVER_assert(k - 1 >= 0, \"Array index k-1 negative\");\n        \n        __CPROVER_assert(\n            (k == ms + 1) ||\n            (arr_n[k] == arr_h[k]),\n            \"Loop invariant: all positions from k to ms have matched\"\n        );\n        \n        k--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/memmem.c",
    "line": 44,
    "column": 2,
    "source_code": "for (i=0; i<l; i++)\n\t\tBITOP(byteset, n[i], |=), shift[n[i]] = i+1;",
    "abstract_code": "for (i=0; i<l; i++)\n\t\tBITOP(byteset, arr_n[i], |=), arr_shift[arr_n[i]] = i+1;",
    "ptr_map": {
      "n": "n_idx",
      "shift": "shift_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 256\n#define L 100\n\nint main() {\n    unsigned char byteset = 0;\n    unsigned char arr_n[L];\n    unsigned char arr_shift[N];\n    size_t i = 0;\n\n    __CPROVER_assume(L > 0 && L <= N);\n    for (size_t k = 0; k < L; k++) {\n        __CPROVER_assume(arr_n[k] < N);\n    }\n    for (size_t k = 0; k < N; k++) {\n        arr_shift[k] = 0;\n    }\n\n    while (i < L) {\n        __CPROVER_assert(\n            (i == 0) ||\n            (arr_shift[arr_n[i-1]] == i),\n            \"Loop invariant violated\"\n        );\n\n        byteset |= arr_n[i];\n        arr_shift[arr_n[i]] = i + 1;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/memmem.c",
    "line": 49,
    "column": 2,
    "source_code": "while (jp+k<l) {\n\t\tif (n[ip+k] == n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (n[ip+k] > n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "abstract_code": "while (jp+k<l) {\n\t\tif (arr_n[ip+k] == arr_n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (arr_n[ip+k] > arr_n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "ptr_map": {
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define L 50\n\nint main() {\n    unsigned char arr_n[N];\n    size_t ip = 0, jp = 0, k = 1, p = 1;\n    size_t l = L;\n\n    __CPROVER_assume(l < N);\n    __CPROVER_assume(ip < l && jp < l && ip <= jp);\n    __CPROVER_assume(k >= 1 && p >= 1);\n    __CPROVER_assume(jp + k <= l);\n\n    while (jp + k < l) {\n        __CPROVER_assert(ip < l && jp < l && ip <= jp, \"Indices within bounds and ip <= jp\");\n        __CPROVER_assert(k >= 1 && p >= 1, \"k and p positive\");\n        __CPROVER_assert(ip + k < N && jp + k < N, \"Array access in bounds\");\n\n        if (arr_n[ip + k] == arr_n[jp + k]) {\n            if (k == p) {\n                jp += p;\n                k = 1;\n            } else k++;\n        } else if (arr_n[ip + k] > arr_n[jp + k]) {\n            jp += k;\n            k = 1;\n            p = jp - ip;\n        } else {\n            ip = jp++;\n            k = p = 1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/memmem.c",
    "line": 69,
    "column": 2,
    "source_code": "while (jp+k<l) {\n\t\tif (n[ip+k] == n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (n[ip+k] < n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "abstract_code": "while (jp+k<l) {\n\t\tif (arr_n[ip+k] == arr_n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (arr_n[ip+k] < arr_n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "ptr_map": {
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define L 50\n\nint main() {\n    unsigned char arr_n[N];\n    size_t ip = 0, jp = 0, k = 1, p = 1;\n    size_t l = L;\n\n    __CPROVER_assume(l > 0 && l < N);\n    __CPROVER_assume(ip < l && jp < l);\n    __CPROVER_assume(k >= 1 && p >= 1);\n    __CPROVER_assume(jp + k <= l);\n\n    for (size_t idx = 0; idx < N; ++idx) {\n        __CPROVER_assume(arr_n[idx] >= 0);\n    }\n\n    while (jp + k < l) {\n        __CPROVER_assert(ip < l && jp < l && ip + k < l && jp + k < l, \"Array bounds safety\");\n        __CPROVER_assert(k >= 1 && p >= 1, \"Positive k and p\");\n        __CPROVER_assert(jp >= ip, \"jp never less than ip\");\n\n        if (arr_n[ip + k] == arr_n[jp + k]) {\n            if (k == p) {\n                jp += p;\n                k = 1;\n            } else k++;\n        } else if (arr_n[ip + k] < arr_n[jp + k]) {\n            jp += k;\n            k = 1;\n            p = jp - ip;\n        } else {\n            ip = jp++;\n            k = p = 1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/memmem.c",
    "line": 115,
    "column": 3,
    "source_code": "for (k=MAX(ms+1,mem); k<l && n[k] == h[k]; k++);\n",
    "abstract_code": "for (k=MAX(ms+1,mem); k<l && arr_n[k] == arr_h[k]; k++);\n",
    "ptr_map": {
      "h": "h_idx",
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define MAX(a,b) ((a)>(b)?(a):(b))\n\nint main() {\n    size_t arr_n[N];\n    size_t arr_h[N];\n    size_t ms, mem, l;\n    size_t k;\n\n    __CPROVER_assume(N > 0);\n    __CPROVER_assume(l <= N);\n    __CPROVER_assume(ms < N);\n    __CPROVER_assume(mem < N);\n\n    k = MAX(ms + 1, mem);\n\n    while (k < l && arr_n[k] == arr_h[k]) {\n        __CPROVER_assert(k < N, \"Array index out of bounds for arr_n\");\n        __CPROVER_assert(k < N, \"Array index out of bounds for arr_h\");\n        __CPROVER_assert(\n            k >= MAX(ms + 1, mem) && k <= l,\n            \"Loop index within expected range\"\n        );\n        __CPROVER_assert(\n            arr_n[k] == arr_h[k],\n            \"Loop condition holds\"\n        );\n        k++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/memmem.c",
    "line": 122,
    "column": 3,
    "source_code": "for (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);\n",
    "abstract_code": "for (k=ms+1; k>mem && arr_n[k-1] == arr_h[k-1]; k--);\n",
    "ptr_map": {
      "h": "h_idx",
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define MEM 0\n\nint main() {\n    size_t arr_n[N];\n    size_t arr_h[N];\n    size_t ms = N / 2;\n    size_t k = ms + 1;\n\n    __CPROVER_assume(ms + 1 < N);\n    __CPROVER_assume(MEM >= 0 && MEM < N);\n\n    for (size_t i = 0; i < N; ++i) {\n        __CPROVER_assume(arr_n[i] == arr_h[i]);\n    }\n\n    while (k > MEM && arr_n[k - 1] == arr_h[k - 1]) {\n        __CPROVER_assert(\n            k <= ms + 1 && k > MEM,\n            \"Loop invariant: k is within valid decreasing range\"\n        );\n        k--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/swab.c",
    "line": 7,
    "column": 2,
    "source_code": "for (; n>1; n-=2) {\n\t\tdest[0] = src[1];\n\t\tdest[1] = src[0];\n\t\tdest += 2;\n\t\tsrc += 2;\n\t}\n",
    "abstract_code": "for (; n>1; n-=2) {\n\t\tarr_dest[0] = arr_src[1];\n\t\tarr_dest[1] = arr_src[0];\n\t\tdest += 2;\n\t\tsrc += 2;\n\t}\n",
    "ptr_map": {
      "src": "src_idx",
      "dest": "dest_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    unsigned char arr_src[N];\n    unsigned char arr_dest[N];\n    size_t src_idx = 0;\n    size_t dest_idx = 0;\n    size_t n = N;\n\n    __CPROVER_assume(n > 1 && n % 2 == 0);\n    __CPROVER_assume(src_idx + n <= N);\n    __CPROVER_assume(dest_idx + n <= N);\n\n    while (n > 1) {\n        __CPROVER_assert(src_idx + 2 <= N && dest_idx + 2 <= N, \"Array bounds\");\n        __CPROVER_assert(src_idx < N && dest_idx < N, \"Index in bounds\");\n\n        arr_dest[dest_idx] = arr_src[src_idx + 1];\n        arr_dest[dest_idx + 1] = arr_src[src_idx];\n\n        dest_idx += 2;\n        src_idx += 2;\n        n -= 2;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/wcsstr.c",
    "line": 12,
    "column": 2,
    "source_code": "for (l=0; n[l] && h[l]; l++);\n",
    "abstract_code": "for (l=0; arr_n[l] && arr_h[l]; l++);\n",
    "ptr_map": {
      "h": "h_idx",
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_n[N];\n    size_t arr_h[N];\n    size_t l = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_n[k] == 0 || arr_n[k] == 1);\n        __CPROVER_assume(arr_h[k] == 0 || arr_h[k] == 1);\n    }\n\n    while (l < N && arr_n[l] && arr_h[l]) {\n        __CPROVER_assert(l < N, \"Loop index within bounds\");\n        l++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/wcsstr.c",
    "line": 17,
    "column": 2,
    "source_code": "while (jp+k<l) {\n\t\tif (n[ip+k] == n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (n[ip+k] > n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "abstract_code": "while (jp+k<l) {\n\t\tif (arr_n[ip+k] == arr_n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (arr_n[ip+k] > arr_n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "ptr_map": {
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define L 50\n\nint main() {\n    size_t arr_n[N];\n    size_t ip = 0, jp = 0, k = 1, p = 1;\n    size_t l = L;\n\n    __CPROVER_assume(l < N);\n    __CPROVER_assume(ip < l && jp < l);\n    __CPROVER_assume(k >= 1 && p >= 1);\n    for (size_t idx = 0; idx < N; ++idx) {\n        __CPROVER_assume(arr_n[idx] < 1000);\n    }\n\n    while (jp + k < l) {\n        __CPROVER_assert(\n            ip < l && jp < l && k >= 1 && p >= 1,\n            \"Loop invariant: indices within bounds and positive step\"\n        );\n        __CPROVER_assert(\n            jp >= ip,\n            \"Loop invariant: jp never less than ip\"\n        );\n        __CPROVER_assert(\n            p == jp - ip || (ip == jp && p == 1),\n            \"Loop invariant: p equals jp - ip or reset condition\"\n        );\n\n        if (arr_n[ip + k] == arr_n[jp + k]) {\n            if (k == p) {\n                jp += p;\n                k = 1;\n            } else k++;\n        } else if (arr_n[ip + k] > arr_n[jp + k]) {\n            jp += k;\n            k = 1;\n            p = jp - ip;\n        } else {\n            ip = jp++;\n            k = p = 1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/wcsstr.c",
    "line": 37,
    "column": 2,
    "source_code": "while (jp+k<l) {\n\t\tif (n[ip+k] == n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (n[ip+k] < n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "abstract_code": "while (jp+k<l) {\n\t\tif (arr_n[ip+k] == arr_n[jp+k]) {\n\t\t\tif (k == p) {\n\t\t\t\tjp += p;\n\t\t\t\tk = 1;\n\t\t\t} else k++;\n\t\t} else if (arr_n[ip+k] < arr_n[jp+k]) {\n\t\t\tjp += k;\n\t\t\tk = 1;\n\t\t\tp = jp - ip;\n\t\t} else {\n\t\t\tip = jp++;\n\t\t\tk = p = 1;\n\t\t}\n\t}\n",
    "ptr_map": {
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define L 50\n\nint main() {\n    int arr_n[N];\n    int ip = 0, jp = 0, k = 1, p = 1;\n    int l = L;\n\n    __CPROVER_assume(l > 0 && l < N);\n    __CPROVER_assume(ip >= 0 && jp >= 0 && k >= 1 && p >= 1);\n    __CPROVER_assume(ip + k < N && jp + k < N);\n\n    while (jp + k < l) {\n        __CPROVER_assert(\n            ip >= 0 && jp >= 0 && k >= 1 && p >= 1,\n            \"Loop invariant: positive indices and step\"\n        );\n        __CPROVER_assert(\n            ip + k < N && jp + k < N,\n            \"Loop invariant: array access bounds\"\n        );\n        __CPROVER_assert(\n            jp >= ip,\n            \"Loop invariant: jp never less than ip\"\n        );\n\n        if (arr_n[ip + k] == arr_n[jp + k]) {\n            if (k == p) {\n                jp += p;\n                k = 1;\n            } else k++;\n        } else if (arr_n[ip + k] < arr_n[jp + k]) {\n            jp += k;\n            k = 1;\n            p = jp - ip;\n        } else {\n            ip = jp++;\n            k = p = 1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/wcsstr.c",
    "line": 79,
    "column": 3,
    "source_code": "for (k=MAX(ms+1,mem); n[k] && n[k] == h[k]; k++);\n",
    "abstract_code": "for (k=MAX(ms+1,mem); arr_n[k] && arr_n[k] == arr_h[k]; k++);\n",
    "ptr_map": {
      "h": "h_idx",
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_n[N];\n    size_t arr_h[N];\n    size_t ms, mem, k;\n\n    __CPROVER_assume(N > 0);\n    for (size_t idx = 0; idx < N; idx++) {\n        __CPROVER_assume(arr_n[idx] == 0 || arr_n[idx] != 0);\n        __CPROVER_assume(arr_h[idx] == 0 || arr_h[idx] != 0);\n    }\n\n    __CPROVER_assume(ms < N && mem < N);\n    size_t start = (ms + 1) > mem ? (ms + 1) : mem;\n    __CPROVER_assume(start < N);\n\n    k = start;\n    while (k < N && arr_n[k] != 0 && arr_n[k] == arr_h[k]) {\n        __CPROVER_assert(\n            k >= start && k < N,\n            \"Loop invariant: index within bounds\"\n        );\n        __CPROVER_assert(\n            arr_n[k] == arr_h[k],\n            \"Loop invariant: equality holds for all visited positions\"\n        );\n        k++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/string/wcsstr.c",
    "line": 86,
    "column": 3,
    "source_code": "for (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);\n",
    "abstract_code": "for (k=ms+1; k>mem && arr_n[k-1] == arr_h[k-1]; k--);\n",
    "ptr_map": {
      "h": "h_idx",
      "n": "n_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_n[N];\n    size_t arr_h[N];\n    size_t mem = 0;\n    size_t ms = 0;\n    size_t k;\n\n    __CPROVER_assume(N > 0);\n    __CPROVER_assume(ms + 1 < N);\n    __CPROVER_assume(mem < N);\n    __CPROVER_assume(mem <= ms + 1);\n\n    for (size_t idx = 0; idx < N; idx++) {\n        __CPROVER_assume(arr_n[idx] < 10);\n        __CPROVER_assume(arr_h[idx] < 10);\n    }\n\n    k = ms + 1;\n    while (k > mem && arr_n[k - 1] == arr_h[k - 1]) {\n        __CPROVER_assert(\n            k <= ms + 1 && k > mem,\n            \"Loop invariant: index bounds\"\n        );\n        __CPROVER_assert(\n            (k == ms + 1) || (arr_n[k] != arr_h[k]),\n            \"Loop invariant: mismatch at current position\"\n        );\n        k--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/string/wmemmove.c",
    "line": 9,
    "column": 3,
    "source_code": "while (n--) d[n] = s[n];",
    "abstract_code": "while (n--) arr_d[n] = arr_s[n];",
    "ptr_map": {
      "d": "d_idx",
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t n = N;\n    size_t arr_s[N];\n    size_t arr_d[N];\n\n    __CPROVER_assume(n > 0 && n <= N);\n    for (size_t k = 0; k < N; ++k) {\n        __CPROVER_assume(arr_s[k] < 1000);\n    }\n\n    while (n--) {\n        __CPROVER_assert(n < N, \"Loop invariant: index within bounds for arr_d\");\n        __CPROVER_assert(n < N, \"Loop invariant: index within bounds for arr_s\");\n        arr_d[n] = arr_s[n];\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/linux/prctl.c",
    "line": 11,
    "column": 2,
    "source_code": "for (i=0; i<4; i++) x[i] = va_arg(ap, unsigned long);",
    "abstract_code": "for (i=0; i<4; i++) arr_x[i] = va_arg(ap, unsigned long);",
    "ptr_map": {
      "x": "x_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 4\n\nint main() {\n    unsigned long arr_x[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n\n    while (i < N) {\n        __CPROVER_assert(i >= 0 && i < N, \"Loop invariant: array index within bounds\");\n        arr_x[i] = nondet_unsigned_long();\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/stdio/vfscanf.c",
    "line": 218,
    "column": 7,
    "source_code": "for (c=p++[-1]; c<*p; c++)\n\t\t\t\t\t\t\tscanset[1+c] = 1-invert;",
    "abstract_code": "for (c=p++[-1]; c<*p; c++)\n\t\t\t\t\t\t\tarr_scanset[1+c] = 1-invert;",
    "ptr_map": {
      "scanset": "scanset_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_scanset[N];\n    int invert = 0;\n    int p[2] = {0, 0};\n    int c;\n\n    __CPROVER_assume(N > 2);\n    __CPROVER_assume(p[0] >= 0 && p[0] < N - 1);\n    __CPROVER_assume(p[1] >= p[0] + 1 && p[1] < N - 1);\n\n    c = p[0];\n    p[0] = p[1];\n\n    while (c < p[0]) {\n        __CPROVER_assert(c >= 0 && 1 + c < N, \"Array access within bounds\");\n        arr_scanset[1 + c] = 1 - invert;\n        c++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/stdio/vfprintf.c",
    "line": 155,
    "column": 2,
    "source_code": "for (; x; x>>=4) *--s = xdigits[(x&15)]|lower;",
    "abstract_code": "for (; x; x>>=4) *--s = arr_xdigits[(x&15)]|lower;",
    "ptr_map": {
      "xdigits": "xdigits_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define LOWER 32\n\nint main() {\n    char arr_xdigits[N];\n    char *s = &arr_xdigits[N - 1];\n    unsigned int x;\n    char lower = LOWER;\n\n    __CPROVER_assume(x > 0);\n    __CPROVER_assume(s == &arr_xdigits[N - 1]);\n\n    while (x != 0) {\n        __CPROVER_assert(s >= arr_xdigits && s < arr_xdigits + N, \"Loop invariant: s within array bounds\");\n        \n        unsigned int idx = x & 15;\n        __CPROVER_assume(idx < N);\n        *--s = arr_xdigits[idx] | lower;\n        x >>= 4;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/stdio/vfprintf.c",
    "line": 287,
    "column": 3,
    "source_code": "while (z>a && !z[-1]) z--;",
    "abstract_code": "while (z>a && !arr_z[-1]) z_idx--;",
    "ptr_map": {
      "z": "z_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t a = 0;\n    size_t z_idx = N - 1;\n    int arr_z[N];\n\n    __CPROVER_assume(a < N);\n    __CPROVER_assume(z_idx < N);\n    __CPROVER_assume(z_idx >= a);\n\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_z[k] == 0 || arr_z[k] == 1);\n    }\n\n    while (z_idx > a && !arr_z[z_idx - 1]) {\n        __CPROVER_assert(\n            (z_idx < N) &&\n            (z_idx > a) &&\n            (arr_z[z_idx - 1] == 0),\n            \"Loop invariant violated\"\n        );\n        z_idx--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/stdio/vfprintf.c",
    "line": 343,
    "column": 2,
    "source_code": "for (; z>a && !z[-1]; z--);\n",
    "abstract_code": "for (; z>a && !arr_z[-1]; z_idx--);\n",
    "ptr_map": {
      "z": "z_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_z[N];\n    size_t a = 0;\n    size_t z_idx = N - 1;\n\n    __CPROVER_assume(a < N);\n    __CPROVER_assume(z_idx < N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_z[k] == 0 || arr_z[k] == 1);\n    }\n\n    while (z_idx > a && arr_z[z_idx - 1] == 0) {\n        __CPROVER_assert(\n            (z_idx < N) &&\n            (z_idx > a) &&\n            (arr_z[z_idx - 1] == 0),\n            \"Loop invariant violated\"\n        );\n        z_idx--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/stdio/vfprintf.c",
    "line": 356,
    "column": 22,
    "source_code": "for (i=10, j=0; z[-1]%i==0; i*=10, j++);\n",
    "abstract_code": "for (i=10, j=0; arr_z[-1]%i==0; i*=10, j++);\n",
    "ptr_map": {
      "z": "z_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_z[N];\n    int i, j;\n    \n    __CPROVER_assume(N > 0);\n    __CPROVER_assume(arr_z[-1] > 0);\n    \n    for (i = 10, j = 0; arr_z[-1] % i == 0; i *= 10, j++) {\n        __CPROVER_assert(\n            i == 10 * (int)__CPROVER_pow(10, j) && \n            j >= 0 && \n            arr_z[-1] % (i / 10) == 0,\n            \"Loop invariant violated\"\n        );\n    }\n    \n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/stdio/fwrite.c",
    "line": 14,
    "column": 3,
    "source_code": "for (i=l; i && s[i-1] != '\\n'; i--);\n",
    "abstract_code": "for (i=l; i && arr_s[i-1] != '\\n'; i--);\n",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_s[N];\n    size_t i, l;\n\n    __CPROVER_assume(l > 0 && l < N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_s[k] != '\\n');\n    }\n\n    i = l;\n    while (i != 0 && arr_s[i - 1] != '\\n') {\n        __CPROVER_assert(i > 0 && i <= l, \"Loop invariant: i stays within (0, l]\");\n        i--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "WHILE_STMT",
    "file_path": "../musl/src/stdio/gets.c",
    "line": 10,
    "column": 2,
    "source_code": "while ((c=getc_unlocked(stdin)) != EOF && c != '\\n') s[i++] = c;",
    "abstract_code": "while ((c=getc_unlocked(stdin)) != EOF && c != '\\n') arr_s[i++] = c;",
    "ptr_map": {
      "s": "s_idx"
    },
    "invariant": "#include <stdio.h>\n#include <stddef.h>\n#define N 100\n#define EOF (-1)\n\nint main() {\n    char arr_s[N];\n    int c;\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n\n    while (1) {\n        c = getc_unlocked(stdin);\n        if (c == EOF || c == '\\n') break;\n\n        __CPROVER_assert(i < N, \"Array index out of bounds\");\n        arr_s[i++] = (char)c;\n\n        __CPROVER_assert(i <= N, \"Loop invariant: i never exceeds N\");\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/floatscan.c",
    "line": 93,
    "column": 2,
    "source_code": "for (; c-'0'<10U || c=='.'; c = shgetc(f)) {\n\t\tif (c == '.') {\n\t\t\tif (gotrad) break;\n\t\t\tgotrad = 1;\n\t\t\tlrp = dc;\n\t\t} else if (k < KMAX-3) {\n\t\t\tdc++;\n\t\t\tif (c!='0') lnz = dc;\n\t\t\tif (j) x[k] = x[k]*10 + c-'0';\n\t\t\telse x[k] = c-'0';\n\t\t\tif (++j==9) {\n\t\t\t\tk++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\tgotdig=1;\n\t\t} else {\n\t\t\tdc++;\n\t\t\tif (c!='0') {\n\t\t\t\tlnz = (KMAX-4)*9;\n\t\t\t\tx[KMAX-4] |= 1;\n\t\t\t}\n\t\t}\n\t}\n",
    "abstract_code": "for (; c-'0'<10U || c=='.'; c = shgetc(f)) {\n\t\tif (c == '.') {\n\t\t\tif (gotrad) break;\n\t\t\tgotrad = 1;\n\t\t\tlrp = dc;\n\t\t} else if (k < KMAX-3) {\n\t\t\tdc++;\n\t\t\tif (c!='0') lnz = dc;\n\t\t\tif (j) arr_x[k] = arr_x[k]*10 + c-'0';\n\t\t\telse arr_x[k] = c-'0';\n\t\t\tif (++j==9) {\n\t\t\t\tk++;\n\t\t\t\tj=0;\n\t\t\t}\n\t\t\tgotdig=1;\n\t\t} else {\n\t\t\tdc++;\n\t\t\tif (c!='0') {\n\t\t\t\tlnz = (KMAX-4)*9;\n\t\t\t\tarr_x[KMAX-4] |= 1;\n\t\t\t}\n\t\t}\n\t}\n",
    "ptr_map": {
      "x": "x_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n\n#define KMAX 20\n#define N (KMAX)\n\nint main() {\n    unsigned char c;\n    int gotrad = 0;\n    int dc = 0;\n    int k = 0;\n    int j = 0;\n    int lnz = 0;\n    int gotdig = 0;\n    int lrp = 0;\n    uint32_t arr_x[N];\n    int i;\n\n    for (i = 0; i < N; i++) {\n        arr_x[i] = 0;\n    }\n\n    __CPROVER_assume(c >= '0' && c <= '9' || c == '.');\n\n    while ((c - '0') < 10U || c == '.') {\n        __CPROVER_assert(k >= 0 && k < N, \"k index bounds\");\n        __CPROVER_assert(dc >= 0, \"dc non-negative\");\n        __CPROVER_assert(j >= 0 && j < 9, \"j in range 0..8\");\n        __CPROVER_assert(!gotrad || lrp >= 0, \"lrp valid if gotrad set\");\n\n        if (c == '.') {\n            if (gotrad) break;\n            gotrad = 1;\n            lrp = dc;\n        } else if (k < KMAX - 3) {\n            dc++;\n            if (c != '0') lnz = dc;\n            if (j) arr_x[k] = arr_x[k] * 10 + (c - '0');\n            else arr_x[k] = c - '0';\n            if (++j == 9) {\n                k++;\n                j = 0;\n            }\n            gotdig = 1;\n        } else {\n            dc++;\n            if (c != '0') {\n                lnz = (KMAX - 4) * 9;\n                arr_x[KMAX - 4] |= 1;\n            }\n        }\n\n        c = __CPROVER_nondet_uchar();\n        __CPROVER_assume(c >= '0' && c <= '9' || c == '.');\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/floatscan.c",
    "line": 156,
    "column": 3,
    "source_code": "for (; j<9; j++) x[k]*=10;",
    "abstract_code": "for (; j<9; j++) arr_x[k]*=10;",
    "ptr_map": {
      "x": "x_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_x[N];\n    int k;\n    int j = 0;\n\n    __CPROVER_assume(k >= 0 && k < N);\n    __CPROVER_assume(j >= 0 && j <= 9);\n\n    while (j < 9) {\n        __CPROVER_assert(j >= 0 && j < 9, \"Loop index bounds\");\n        arr_x[k] *= 10;\n        j++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/floatscan.c",
    "line": 176,
    "column": 2,
    "source_code": "for (; !x[z-1]; z--);\n",
    "abstract_code": "for (; !arr_x[z-1]; z--);\n",
    "ptr_map": {
      "x": "x_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_x[N];\n    size_t z = N;\n\n    __CPROVER_assume(z > 0 && z <= N);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_x[k] == 0 || arr_x[k] == 1);\n    }\n\n    while (z > 0 && !arr_x[z - 1]) {\n        __CPROVER_assert(z > 0 && z <= N, \"Loop invariant: index bounds\");\n        z--;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/floatscan.c",
    "line": 183,
    "column": 3,
    "source_code": "for (k=a; k!=z; k++) {\n\t\t\tuint32_t tmp = x[k] % p10;\n\t\t\tx[k] = x[k]/p10 + carry;\n\t\t\tcarry = 1000000000/p10 * tmp;\n\t\t\tif (k==a && !x[k]) {\n\t\t\t\ta = (a+1 & MASK);\n\t\t\t\trp -= 9;\n\t\t\t}\n\t\t}\n",
    "abstract_code": "for (k=a; k!=z; k++) {\n\t\t\tuint32_t tmp = arr_x[k] % p10;\n\t\t\tarr_x[k] = arr_x[k]/p10 + carry;\n\t\t\tcarry = 1000000000/p10 * tmp;\n\t\t\tif (k==a && !arr_x[k]) {\n\t\t\t\ta = (a+1 & MASK);\n\t\t\t\trp -= 9;\n\t\t\t}\n\t\t}\n",
    "ptr_map": {
      "x": "x_idx"
    },
    "invariant": "#include <stdint.h>\n#include <stddef.h>\n\n#define N 100\n#define MASK 0xFF\n\nint main() {\n    uint32_t arr_x[N];\n    uint32_t p10;\n    uint32_t carry;\n    uint32_t a, z, k;\n    int rp;\n\n    __CPROVER_assume(p10 > 0 && p10 <= 1000000000);\n    __CPROVER_assume(a < N && z < N && a <= z);\n    __CPROVER_assume(carry < 1000000000 / p10);\n\n    for (k = a; k != z; k++) {\n        __CPROVER_assert(k >= a && k < N, \"Loop index bounds\");\n        uint32_t tmp = arr_x[k] % p10;\n        uint32_t old_arr_x_k = arr_x[k];\n        arr_x[k] = arr_x[k] / p10 + carry;\n        carry = 1000000000 / p10 * tmp;\n        if (k == a && !arr_x[k]) {\n            a = (a + 1) & MASK;\n            rp -= 9;\n        }\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/floatscan.c",
    "line": 200,
    "column": 3,
    "source_code": "for (k=(z-1 & MASK); ; k=(k-1 & MASK)) {\n\t\t\tuint64_t tmp = ((uint64_t)x[k] << 29) + carry;\n\t\t\tif (tmp > 1000000000) {\n\t\t\t\tcarry = tmp / 1000000000;\n\t\t\t\tx[k] = tmp % 1000000000;\n\t\t\t} else {\n\t\t\t\tcarry = 0;\n\t\t\t\tx[k] = tmp;\n\t\t\t}\n\t\t\tif (k==(z-1 & MASK) && k!=a && !x[k]) z = k;\n\t\t\tif (k==a) break;\n\t\t}\n",
    "abstract_code": "for (k=(z-1 & MASK); ; k=(k-1 & MASK)) {\n\t\t\tuint64_t tmp = ((uint64_t)arr_x[k] << 29) + carry;\n\t\t\tif (tmp > 1000000000) {\n\t\t\t\tcarry = tmp / 1000000000;\n\t\t\t\tarr_x[k] = tmp % 1000000000;\n\t\t\t} else {\n\t\t\t\tcarry = 0;\n\t\t\t\tarr_x[k] = tmp;\n\t\t\t}\n\t\t\tif (k==(z-1 & MASK) && k!=a && !arr_x[k]) z = k;\n\t\t\tif (k==a) break;\n\t\t}\n",
    "ptr_map": {
      "x": "x_idx"
    },
    "invariant": "#include <stdint.h>\n#include <stddef.h>\n\n#define MASK 0xFF\n#define N 256\n#define LIMIT 1000000000UL\n\nint main() {\n    uint32_t arr_x[N];\n    uint64_t carry = 0;\n    unsigned int k, a, z;\n    unsigned int initial_k;\n\n    __CPROVER_assume(a < N && z < N);\n    __CPROVER_assume(a != z);\n    for (size_t idx = 0; idx < N; ++idx) {\n        __CPROVER_assume(arr_x[idx] < LIMIT);\n    }\n\n    k = (z - 1) & MASK;\n    initial_k = k;\n\n    while (1) {\n        __CPROVER_assert(k < N, \"Array index within bounds\");\n        __CPROVER_assert(carry < LIMIT, \"Carry stays within limit\");\n\n        uint64_t tmp = ((uint64_t)arr_x[k] << 29) + carry;\n        if (tmp > LIMIT) {\n            carry = tmp / LIMIT;\n            arr_x[k] = tmp % LIMIT;\n        } else {\n            carry = 0;\n            arr_x[k] = (uint32_t)tmp;\n        }\n\n        if (k == initial_k && k != a && arr_x[k] == 0) {\n            z = k;\n        }\n\n        if (k == a) break;\n\n        k = (k - 1) & MASK;\n    }\n\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/floatscan.c",
    "line": 227,
    "column": 3,
    "source_code": "for (i=0; i<LD_B1B_DIG; i++) {\n\t\t\tk = (a+i & MASK);\n\t\t\tif (k == z || x[k] < th[i]) {\n\t\t\t\ti=LD_B1B_DIG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (x[a+i & MASK] > th[i]) break;\n\t\t}\n",
    "abstract_code": "for (i=0; i<LD_B1B_DIG; i++) {\n\t\t\tk = (a+i & MASK);\n\t\t\tif (k == z || arr_x[k] < arr_th[i]) {\n\t\t\t\ti=LD_B1B_DIG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (arr_x[a+i & MASK] > arr_th[i]) break;\n\t\t}\n",
    "ptr_map": {
      "th": "th_idx",
      "x": "x_idx"
    },
    "invariant": "#include <stddef.h>\n#define LD_B1B_DIG 100\n#define MASK 0xFF\n#define N 256\n\nint main() {\n    unsigned int arr_x[N];\n    unsigned int arr_th[LD_B1B_DIG];\n    unsigned int a, z, k, i;\n\n    __CPROVER_assume(a < N && z < N);\n    for (size_t idx = 0; idx < N; idx++) {\n        __CPROVER_assume(arr_x[idx] < 1024);\n    }\n    for (size_t idx = 0; idx < LD_B1B_DIG; idx++) {\n        __CPROVER_assume(arr_th[idx] < 1024);\n    }\n\n    i = 0;\n    while (i < LD_B1B_DIG) {\n        __CPROVER_assert(i < LD_B1B_DIG, \"Loop index within bounds\");\n\n        k = (a + i) & MASK;\n        if (k == z || arr_x[k] < arr_th[i]) {\n            i = LD_B1B_DIG;\n            break;\n        }\n        if (arr_x[(a + i) & MASK] > arr_th[i]) break;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/floatscan.c",
    "line": 239,
    "column": 3,
    "source_code": "for (k=a; k!=z; k=(k+1 & MASK)) {\n\t\t\tuint32_t tmp = x[k] & (1<<sh)-1;\n\t\t\tx[k] = (x[k]>>sh) + carry;\n\t\t\tcarry = (1000000000>>sh) * tmp;\n\t\t\tif (k==a && !x[k]) {\n\t\t\t\ta = (a+1 & MASK);\n\t\t\t\ti--;\n\t\t\t\trp -= 9;\n\t\t\t}\n\t\t}\n",
    "abstract_code": "for (k=a; k!=z; k=(k+1 & MASK)) {\n\t\t\tuint32_t tmp = arr_x[k] & (1<<sh)-1;\n\t\t\tarr_x[k] = (arr_x[k]>>sh) + carry;\n\t\t\tcarry = (1000000000>>sh) * tmp;\n\t\t\tif (k==a && !arr_x[k]) {\n\t\t\t\ta = (a+1 & MASK);\n\t\t\t\ti--;\n\t\t\t\trp -= 9;\n\t\t\t}\n\t\t}\n",
    "ptr_map": {
      "x": "x_idx"
    },
    "invariant": "#include <stdint.h>\n#include <stddef.h>\n\n#define MASK 0xFF\n#define N 256\n#define SH 5\n\nint main() {\n    uint32_t arr_x[N];\n    uint32_t carry = 0;\n    uint32_t a = 0;\n    uint32_t z = 0;\n    uint32_t k;\n    int i = 0;\n    int rp = 0;\n    uint32_t sh = SH;\n\n    __CPROVER_assume(a < N && z < N);\n    __CPROVER_assume(a != z);\n    for (size_t idx = 0; idx < N; ++idx) {\n        __CPROVER_assume(arr_x[idx] < (1U << 31));\n    }\n\n    k = a;\n    while (k != z) {\n        __CPROVER_assert(k < N, \"k within bounds\");\n        uint32_t tmp = arr_x[k] & ((1U << sh) - 1);\n        uint32_t old_arr_x_k = arr_x[k];\n        arr_x[k] = (arr_x[k] >> sh) + carry;\n        carry = (1000000000U >> sh) * tmp;\n\n        if (k == a && !arr_x[k]) {\n            a = (a + 1) & MASK;\n            i--;\n            rp -= 9;\n        }\n\n        __CPROVER_assert(\n            (arr_x[k] == ((old_arr_x_k >> sh) + carry - (1000000000U >> sh) * tmp)) ||\n            (k == a && !arr_x[k] && arr_x[k] == 0),\n            \"arr_x[k] updated correctly\"\n        );\n\n        k = (k + 1) & MASK;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/floatscan.c",
    "line": 258,
    "column": 2,
    "source_code": "for (y=i=0; i<LD_B1B_DIG; i++) {\n\t\tif ((a+i & MASK)==z) x[(z=(z+1 & MASK))-1] = 0;\n\t\ty = 1000000000.0L * y + x[a+i & MASK];\n\t}\n",
    "abstract_code": "for (y=i=0; i<LD_B1B_DIG; i++) {\n\t\tif ((a+i & MASK)==z) arr_x[(z=(z+1 & MASK))-1] = 0;\n\t\ty = 1000000000.0L * y + arr_x[a+i & MASK];\n\t}\n",
    "ptr_map": {
      "x": "x_idx"
    },
    "invariant": "#include <stddef.h>\n#include <assert.h>\n\n#define LD_B1B_DIG 100\n#define MASK 0xFF\n#define N 256\n\nint main() {\n    long double y = 0.0L;\n    int i = 0;\n    int a = __CPROVER_nondet_int();\n    int z = __CPROVER_nondet_int();\n    int arr_x[N];\n\n    __CPROVER_assume(a >= 0 && a < N);\n    __CPROVER_assume(z >= 0 && z < N);\n    for (int k = 0; k < N; ++k) {\n        arr_x[k] = __CPROVER_nondet_int();\n    }\n\n    while (i < LD_B1B_DIG) {\n        __CPROVER_assert(i >= 0 && i < LD_B1B_DIG, \"Loop index bounds\");\n        int idx1 = (a + i) & MASK;\n        __CPROVER_assert(idx1 >= 0 && idx1 < N, \"Array access idx1 in bounds\");\n        \n        if (idx1 == z) {\n            int new_z = (z + 1) & MASK;\n            __CPROVER_assert(new_z >= 0 && new_z < N, \"New z in bounds\");\n            int write_idx = (new_z - 1) & MASK;\n            __CPROVER_assert(write_idx >= 0 && write_idx < N, \"Write index in bounds\");\n            arr_x[write_idx] = 0;\n            z = new_z;\n        }\n        \n        int idx2 = (a + i) & MASK;\n        __CPROVER_assert(idx2 >= 0 && idx2 < N, \"Array access idx2 in bounds\");\n        y = 1000000000.0L * y + (long double)arr_x[idx2];\n        \n        i++;\n    }\n    \n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/intscan.c",
    "line": 72,
    "column": 3,
    "source_code": "for (x=0; val[c]<base && x<=UINT_MAX/32; c=shgetc(f))\n\t\t\tx = x<<bs | val[c];",
    "abstract_code": "for (x=0; arr_val[c]<base && x<=UINT_MAX/32; c=shgetc(f))\n\t\t\tx = x<<bs | arr_val[c];",
    "ptr_map": {
      "val": "val_idx"
    },
    "invariant": "#include <stddef.h>\n#include <limits.h>\n\n#define N 100\n#define UINT_MAX_32 (UINT_MAX / 32)\n\nint main() {\n    unsigned int arr_val[N];\n    unsigned int base;\n    unsigned int x = 0;\n    unsigned int c = 0;\n    unsigned int bs = 4;\n\n    __CPROVER_assume(base > 0 && base <= 36);\n    __CPROVER_assume(bs > 0 && bs < 32);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_val[k] < base);\n    }\n\n    while (c < N && arr_val[c] < base && x <= UINT_MAX_32) {\n        __CPROVER_assert(\n            x <= UINT_MAX_32,\n            \"Loop invariant: x does not exceed shift limit\"\n        );\n\n        x = (x << bs) | arr_val[c];\n        c++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/intscan.c",
    "line": 74,
    "column": 3,
    "source_code": "for (y=x; val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))\n\t\t\ty = y<<bs | val[c];",
    "abstract_code": "for (y=x; arr_val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))\n\t\t\ty = y<<bs | arr_val[c];",
    "ptr_map": {
      "val": "val_idx"
    },
    "invariant": "#include <stddef.h>\n#include <limits.h>\n\n#define N 100\n#define base 10\n#define bs 4\n#define ULLONG_MAX_shifted (ULLONG_MAX >> bs)\n\nint main() {\n    unsigned long long arr_val[N];\n    unsigned long long y;\n    unsigned long long x = 0;\n    size_t c = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_val[k] < base);\n    }\n\n    y = x;\n    while (c < N && arr_val[c] < base && y <= ULLONG_MAX_shifted) {\n        __CPROVER_assert(\n            y >= x && y <= (ULLONG_MAX_shifted << (bs * c)) + ((1ULL << (bs * c)) - 1),\n            \"Loop invariant violated\"\n        );\n\n        y = (y << bs) | arr_val[c];\n        c++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/intscan.c",
    "line": 77,
    "column": 3,
    "source_code": "for (x=0; val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))\n\t\t\tx = x*base + val[c];",
    "abstract_code": "for (x=0; arr_val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))\n\t\t\tx = x*base + arr_val[c];",
    "ptr_map": {
      "val": "val_idx"
    },
    "invariant": "#include <stddef.h>\n#include <limits.h>\n#define N 100\n#define UINT_MAX_36_MINUS_1 (UINT_MAX/36-1)\n\nint main() {\n    unsigned int arr_val[N];\n    unsigned int base = 10;\n    unsigned int x = 0;\n    unsigned int c = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_val[k] < base);\n    }\n\n    while (c < N && arr_val[c] < base && x <= UINT_MAX_36_MINUS_1) {\n        __CPROVER_assert(\n            x <= UINT_MAX_36_MINUS_1,\n            \"Loop invariant: x does not exceed safe limit\"\n        );\n        x = x * base + arr_val[c];\n        c++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/intscan.c",
    "line": 79,
    "column": 3,
    "source_code": "for (y=x; val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-val[c]; c=shgetc(f))\n\t\t\ty = y*base + val[c];",
    "abstract_code": "for (y=x; arr_val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-arr_val[c]; c=shgetc(f))\n\t\t\ty = y*base + arr_val[c];",
    "ptr_map": {
      "val": "val_idx"
    },
    "invariant": "#include <stddef.h>\n#include <limits.h>\n\n#define N 100\n#define ULLONG_MAX 18446744073709551615ULL\n\nint main() {\n    unsigned long long arr_val[N];\n    unsigned long long base = 10;\n    unsigned long long x = 0;\n    unsigned long long y = x;\n    size_t c = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_val[k] < base);\n    }\n\n    while (c < N && arr_val[c] < base && y <= ULLONG_MAX / base && base * y <= ULLONG_MAX - arr_val[c]) {\n        __CPROVER_assert(\n            y >= x && y <= ULLONG_MAX,\n            \"Loop invariant violated: y remains within bounds and monotonic\"\n        );\n\n        y = y * base + arr_val[c];\n        c++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/intscan.c",
    "line": 83,
    "column": 3,
    "source_code": "for (; val[c]<base; c=shgetc(f));\n",
    "abstract_code": "for (; arr_val[c]<base; c=shgetc(f));\n",
    "ptr_map": {
      "val": "val_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int arr_val[N];\n    int base;\n    int c = 0;\n\n    __CPROVER_assume(c >= 0 && c < N);\n    __CPROVER_assume(base >= 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_val[k] >= 0);\n    }\n\n    while (c < N && arr_val[c] < base) {\n        __CPROVER_assert(c >= 0 && c < N, \"Array index within bounds\");\n        c = c + 1;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/procfdname.c",
    "line": 6,
    "column": 2,
    "source_code": "for (i=0; (buf[i] = \"/proc/self/fd/\"[i]); i++);\n",
    "abstract_code": "for (i=0; (arr_buf[i] = \"/proc/self/fd/\"[i]); i++);\n",
    "ptr_map": {
      "buf": "buf_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    char arr_buf[N];\n    const char *src = \"/proc/self/fd/\";\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n\n    while (i < N) {\n        __CPROVER_assert(i < N, \"Loop invariant: index within bounds\");\n        arr_buf[i] = src[i];\n        if (src[i] == '\\0') {\n            break;\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/internal/procfdname.c",
    "line": 14,
    "column": 2,
    "source_code": "for (; fd; fd/=10) buf[--i] = '0' + fd%10;",
    "abstract_code": "for (; fd; fd/=10) arr_buf[--i] = '0' + fd%10;",
    "ptr_map": {
      "buf": "buf_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    int fd;\n    char arr_buf[N];\n    int i = N - 1;\n\n    __CPROVER_assume(fd > 0);\n    __CPROVER_assume(i >= 0 && i < N);\n\n    while (fd) {\n        __CPROVER_assert(i >= 0 && i < N, \"Loop invariant: index in bounds\");\n        i--;\n        __CPROVER_assume(i >= 0);\n        arr_buf[i] = '0' + fd % 10;\n        fd /= 10;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/env/__libc_start_main.c",
    "line": 27,
    "column": 2,
    "source_code": "for (i=0; envp[i]; i++);\n",
    "abstract_code": "for (i=0; arr_envp[i]; i++);\n",
    "ptr_map": {
      "envp": "envp_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_envp[N];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_envp[k] == 0 || arr_envp[k] > 0);\n    }\n\n    while (i < N && arr_envp[i] != 0) {\n        __CPROVER_assert(i < N, \"Loop index within bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/env/__libc_start_main.c",
    "line": 29,
    "column": 2,
    "source_code": "for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];",
    "abstract_code": "for (i=0; arr_auxv[i]; i+=2) if (arr_auxv[i]<AUX_CNT) arr_aux[arr_auxv[i]] = arr_auxv[i+1];",
    "ptr_map": {
      "aux": "aux_idx",
      "auxv": "auxv_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define AUX_CNT 32\n\nint main() {\n    size_t arr_auxv[N];\n    size_t arr_aux[AUX_CNT];\n    size_t i = 0;\n\n    __CPROVER_assume(N > 1);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_auxv[k] == 0 || arr_auxv[k] < AUX_CNT);\n    }\n\n    while (i < N && arr_auxv[i] != 0) {\n        __CPROVER_assert(\n            i % 2 == 0,\n            \"Loop invariant: i must be even\"\n        );\n        if (arr_auxv[i] < AUX_CNT) {\n            __CPROVER_assume(i + 1 < N);\n            arr_aux[arr_auxv[i]] = arr_auxv[i + 1];\n        }\n        i += 2;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/src/temp/__randname.c",
    "line": 15,
    "column": 2,
    "source_code": "for (i=0; i<6; i++, r>>=5)\n\t\ttemplate[i] = 'A'+(r&15)+(r&16)*2;",
    "abstract_code": "for (i=0; i<6; i++, r>>=5)\n\t\tarr_template[i] = 'A'+(r&15)+(r&16)*2;",
    "ptr_map": {
      "template": "template_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 6\n\nint main() {\n    char arr_template[N];\n    unsigned int r;\n    int i = 0;\n\n    __CPROVER_assume(r >= 0);\n\n    while (i < N) {\n        __CPROVER_assert(i >= 0 && i < N, \"Array index within bounds\");\n        arr_template[i] = 'A' + (r & 15) + (r & 16) * 2;\n        r >>= 5;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/ldso/dlstart.c",
    "line": 29,
    "column": 2,
    "source_code": "for (i=argc+1; argv[i]; i++);\n",
    "abstract_code": "for (i=argc+1; arr_argv[i]; i++);\n",
    "ptr_map": {
      "argv": "argv_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_argv[N];\n    size_t argc;\n    size_t i;\n\n    __CPROVER_assume(argc < N - 1);\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_argv[k] == 0 || arr_argv[k] == 1);\n    }\n\n    i = argc + 1;\n    while (i < N && arr_argv[i] != 0) {\n        __CPROVER_assert(i < N, \"Loop index within bounds\");\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/ldso/dlstart.c",
    "line": 123,
    "column": 3,
    "source_code": "for (i=0; dynv[i]; i+=2) if (dynv[i]==DT_MIPS_LOCAL_GOTNO)\n\t\t\tlocal_cnt = dynv[i+1];",
    "abstract_code": "for (i=0; arr_dynv[i]; i+=2) if (arr_dynv[i]==DT_MIPS_LOCAL_GOTNO)\n\t\t\tlocal_cnt = arr_dynv[i+1];",
    "ptr_map": {
      "dynv": "dynv_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define DT_MIPS_LOCAL_GOTNO 6\n\nint main() {\n    size_t arr_dynv[N];\n    size_t local_cnt = 0;\n    size_t i = 0;\n\n    __CPROVER_assume(N > 1);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_dynv[k] == 0 || arr_dynv[k] == DT_MIPS_LOCAL_GOTNO);\n    }\n\n    while (i < N && arr_dynv[i] != 0) {\n        __CPROVER_assert(\n            (local_cnt == 0) ||\n            (i >= 2 && arr_dynv[i - 2] == DT_MIPS_LOCAL_GOTNO && local_cnt == arr_dynv[i - 1]),\n            \"Loop invariant violated\"\n        );\n\n        if (arr_dynv[i] == DT_MIPS_LOCAL_GOTNO) {\n            __CPROVER_assume(i + 1 < N);\n            local_cnt = arr_dynv[i + 1];\n        }\n        i += 2;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/ldso/dlstart.c",
    "line": 125,
    "column": 3,
    "source_code": "for (i=0; i<local_cnt; i++) got[i] += base;",
    "abstract_code": "for (i=0; i<local_cnt; i++) arr_got[i] += base;",
    "ptr_map": {
      "got": "got_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_got[N];\n    size_t base;\n    size_t local_cnt;\n    size_t i = 0;\n\n    __CPROVER_assume(local_cnt <= N);\n    __CPROVER_assume(local_cnt > 0);\n\n    while (i < local_cnt) {\n        __CPROVER_assert(i < N, \"Loop invariant: index within bounds\");\n        arr_got[i] += base;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/ldso/dlstart.c",
    "line": 152,
    "column": 4,
    "source_code": "for (size_t i=0, bitmap=rel[0]; bitmap>>=1; i++)\n\t\t\t\tif (bitmap&1)\n\t\t\t\t\trelr_addr[i] += base;",
    "abstract_code": "for (size_t i=0, bitmap=arr_rel[0]; bitmap>>=1; i++)\n\t\t\t\tif (bitmap&1)\n\t\t\t\t\tarr_relr_addr[i] += base;",
    "ptr_map": {
      "rel": "rel_idx",
      "relr_addr": "relr_addr_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_rel[N];\n    size_t arr_relr_addr[N];\n    size_t base;\n    size_t bitmap;\n    size_t i;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_relr_addr[k] < __CPROVER_max_malloc_size - base);\n    }\n    __CPROVER_assume(arr_rel[0] < (1ULL << (8 * sizeof(size_t) - 1)));\n\n    i = 0;\n    bitmap = arr_rel[0];\n\n    while (bitmap >>= 1) {\n        __CPROVER_assert(i < N, \"Loop index within bounds\");\n        if (bitmap & 1) {\n            __CPROVER_assume(i < N);\n            arr_relr_addr[i] += base;\n        }\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/ldso/dynlink.c",
    "line": 219,
    "column": 2,
    "source_code": "for (i=0; i<cnt; i++) a[i] = 0;",
    "abstract_code": "for (i=0; i<cnt; i++) arr_a[i] = 0;",
    "ptr_map": {
      "a": "a_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t cnt = N;\n    size_t arr_a[N];\n    size_t i = 0;\n\n    __CPROVER_assume(cnt <= N);\n\n    while (i < cnt) {\n        __CPROVER_assert(i < N, \"Array index within bounds\");\n        arr_a[i] = 0;\n        i++;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/ldso/dynlink.c",
    "line": 220,
    "column": 2,
    "source_code": "for (; v[0]; v+=2) if (v[0]-1<cnt-1) {\n\t\tif (v[0] < 8*sizeof(long))\n\t\t\ta[0] |= 1UL<<v[0];\n\t\ta[v[0]] = v[1];\n\t}\n",
    "abstract_code": "for (; arr_v[0]; v+=2) if (arr_v[0]-1<cnt-1) {\n\t\tif (arr_v[0] < 8*sizeof(long))\n\t\t\tarr_a[0] |= 1UL<<arr_v[0];\n\t\tarr_a[arr_v[0]] = arr_v[1];\n\t}\n",
    "ptr_map": {
      "a": "a_idx",
      "v": "v_idx"
    },
    "invariant": "#include <stddef.h>\n#include <stdint.h>\n#define N 100\n#define CNT 50\n\nint main() {\n    size_t arr_v[N];\n    size_t arr_a[CNT];\n    size_t v_idx = 0;\n    size_t cnt = CNT;\n\n    for (size_t k = 0; k < CNT; k++) {\n        arr_a[k] = 0;\n    }\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_v[k] == 0 || (arr_v[k] > 0 && arr_v[k] < CNT));\n    }\n\n    while (v_idx < N && arr_v[v_idx] != 0) {\n        __CPROVER_assert(\n            (arr_v[v_idx] == 0) ||\n            (arr_v[v_idx] - 1 < cnt - 1 && v_idx + 1 < N && arr_v[v_idx] < CNT),\n            \"Loop invariant violated\"\n        );\n\n        if (arr_v[v_idx] - 1 < cnt - 1) {\n            if (arr_v[v_idx] < 8 * sizeof(long)) {\n                arr_a[0] |= 1UL << arr_v[v_idx];\n            }\n            if (arr_v[v_idx] < CNT) {\n                arr_a[arr_v[v_idx]] = arr_v[v_idx + 1];\n            }\n        }\n        v_idx += 2;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/ldso/dynlink.c",
    "line": 229,
    "column": 2,
    "source_code": "for (; v[0]!=key; v+=2)\n\t\tif (!v[0]) return 0;",
    "abstract_code": "for (; arr_v[0]!=key; v+=2)\n\t\tif (!arr_v[0]) return 0;",
    "ptr_map": {
      "v": "v_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n#define KEY 42\n\nint main() {\n    size_t arr_v[N];\n    size_t v_idx = 0;\n    size_t key = KEY;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_v[k] == 0 || arr_v[k] == key);\n    }\n\n    while (v_idx < N && arr_v[v_idx] != key) {\n        __CPROVER_assert(v_idx < N, \"Array index out of bounds\");\n        \n        if (arr_v[v_idx] == 0) {\n            return 0;\n        }\n        \n        v_idx += 2;\n    }\n    return 0;\n}"
  },
  {
    "project_name": "musl",
    "project_version": "0784374d561435f7c787a555aeab8ede699ed298",
    "kind": "FOR_STMT",
    "file_path": "../musl/ldso/dynlink.c",
    "line": 573,
    "column": 4,
    "source_code": "for (size_t bitmap=relr[0]; (bitmap>>=1); i++)\n\t\t\t\tif (bitmap&1)\n\t\t\t\t\treloc_addr[i] += (size_t)base;",
    "abstract_code": "for (size_t bitmap=arr_relr[0]; (bitmap>>=1); i++)\n\t\t\t\tif (bitmap&1)\n\t\t\t\t\tarr_reloc_addr[i] += (size_t)base;",
    "ptr_map": {
      "reloc_addr": "reloc_addr_idx",
      "relr": "relr_idx"
    },
    "invariant": "#include <stddef.h>\n#define N 100\n\nint main() {\n    size_t arr_relr[N];\n    size_t arr_reloc_addr[N];\n    size_t base = 10;\n    size_t i = 0;\n    size_t bitmap;\n\n    __CPROVER_assume(N > 0);\n    for (size_t k = 0; k < N; k++) {\n        __CPROVER_assume(arr_relr[k] < (1ULL << 63));\n        arr_reloc_addr[k] = __CPROVER_nondet_size_t();\n    }\n\n    bitmap = arr_relr[0];\n    while ((bitmap >>= 1)) {\n        __CPROVER_assert(i < N, \"Index out of bounds\");\n        if (bitmap & 1) {\n            arr_reloc_addr[i] += (size_t)base;\n        }\n        i++;\n    }\n    return 0;\n}"
  }
]